2020-08-28
	Collections
		reverse() 翻转
        rotate(,n) 旋转n位，以循环buffer的概念来旋转 n 位
        sort()  自然排序，定制排序 new Comparator
        shuffle() 随机排序
        swap()  交换 i 和 j 元素
		
		max()
        min()
        replaceAll(,obj1,obj2)		//将 obj1,全部替换成 obj2
        frequency(,obj1)		//统计 obj1 出现的次数
        indexOfSubList(,subList)	//查找subList的索引	
        binarySearch()
        fill(,obj1)	//以obj1 来填充集合，可指定范围
    
    
        emptyXxx()		//创建一个空的、不可改变的XXX对象
        singletonXxx()	//创建一个只有一个元素，且不可改变的对象
        unmodifiableXxx()		//创建普通XXX对象对应的不可变版本
		
		
	Arrays
		sort()		
        binarySearch()
        equals()
        fill()	//填充
        asList()
        toString()
        copyOf()	//实现数组复制
   
   
	static
		
		静态代码块
			静态代码块—>非静态代码块—>构造方法   	//执行顺序
			静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问.
			
			静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 
			
			静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 `Class.forName("ClassDemo")`创建 Class 对象的时候也会执行。
		
		非静态代码块
			非静态代码块与构造函数的区别是：
				非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 
		
		
		静态内部类
			静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：
				1. 它的创建是不需要依赖外围类的创建。
				2. 它不能使用任何外围类的非static成员变量和方法。
			
			public class Singleton {
				//声明为 private 避免调用默认构造方法创建对象
				private Singleton() {
				
				}
				
				// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问
				private static class SingletonHolder {
					private static final Singleton INSTANCE = new Singleton();
				}
				
				public static Singleton getUniqueInstance() {
				return SingletonHolder.INSTANCE;
				}
				}
				
				当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance() `方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。
				这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。
			
		静态方法
			静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。
		
		this 和 super
			在构造器中使用 `super（）` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
			
		
		代理模式
			使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
			代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。
			
			静态代理
				静态代理的实现步骤
					1. 定义一个接口及其实现类；
					2. 创建一个代理类同样实现这个接口
					3. 将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
				
				示例
					见javaDemo->设计模式->代理模式->静态代理模式
			
			
			动态代理
				相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( _CGLIB 动态代理机制_)。
				从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。
				动态代理的实现方式：
					JDK 动态代理
					CGLIB 动态代理
				
				JDK动态代理
					
					机制
						在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。
						Proxy 类中使用频率最高的方法是：newProxyInstance()，这个方法主要用来生成一个代理对象。
						public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,
											InvocationHandler h)throws IllegalArgumentException
											{
												......
											}
						这个方法一共有 3 个参数：
							1. loader:类加载器，用于加载代理对象
							2. interfaces: 被代理类实现的一些接口
							3. h: 实现了 InvocationHandler 接口的对象
						要实现动态代理的话，还必须需要实现InvocationHandler来自定义处理逻辑。 当我们的动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现`InvocationHandler` 接口类的 `invoke` 方法来调用。
						public interface InvocationHandler {
							/**
							* 当你使用代理对象调用方法的时候实际会调用到这个方法
							*/
							public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
						}
						
						invoke()方法有下面三个参数：
							1. proxy:动态生成的代理类
							2. method: 与代理类对象调用的方法相对应
							3. args: 当前 method 方法的参数
						也就是说：你通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法。 你可以在 `invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。
			
					JDK动态代理使用步骤
						1. 定义一个接口及其实现类
						2. 自定义 `InvocationHandler` 并重写`invoke`方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑
						3. 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)` 方法创建代理对象
			
					代码示例见 javaDemo->设计模式->代理模式->jdk 动态代理模式
		
		
		
				CGLIB 动态代理
					JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。
					为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。
			
					CGLIB(_Code Generation Library_)是一个基于[ASM]的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。
					如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。
			
					机制
						在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。
				
						你需要自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法。
				
						public interface MethodInterceptor extends Callback{
							// 拦截被代理类中的方法
							public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy) throws Throwable;
						}
				
						intercept参数：
							1. obj:被代理的对象（需要增强的对象）
							2. method:被拦截的方法（需要增强的方法）
							3. args:方法入参
							4. methodProxy:用于调用原始方法
			
						你可以通过 `Enhancer`类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法。
			
					CGLIB 动态代理类使用步骤
				
						1. 定义一个类；
						2. 自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；
						3. 通过 `Enhancer` 类的 `create()`创建代理类；
				
					示例
						见 javaDemo->设计模式->代理模式-> CGLIB动态代理模式
		
				JDK动态代理和CGLIB 动态代理对比
					1. JDK 动态代理只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
					2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。
		
			静态代理和动态代理的对比
				1. 灵活性：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
				2. JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。
			
	AOP 与 OOP
		OOP:面向对象编程
			它提倡的是将功能模块化，对象化
		
		AOP:面向切面编程
			提倡的是针对同一类问题的统一处理
		
			那么AOP这种编程思想有什么用呢，一般来说，主要用于不想侵入原有代码的场景中，例如SDK需要无侵入的在宿主中插入一些代码，做日志埋点、性能监控、动态权限控制、甚至是代码调试等等。
			
			四种实践 AOP 编程的方案

				AspectJ
					原理：
						实际上是在编译时候，根据一定的规则解析，然后插入一些代码，在不侵入原有代码的基础上，增加新的代码。
					
					目标
						将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。
						比较大型的项目，而且迭代较快，使用OOP太消耗内力。有日志、性能、安全、异常处理等横切关注点需求。

					示例：
						@Before("execution(* android.app.Activity.on**(..))")
   						public void onActivityMethodBefore(JoinPoint joinPoint) throws Throwable {
        					String key = joinPoint.getSignature().toString();
        					Log.d(TAG, "onActivityMethodBefore: " + key);
    					}
					
						在onCreate的最前面，插入了一行AspectJ的代码。这个就是AspectJ的主要功能
					
					具体实践和第三方库
						https://www.jianshu.com/p/5c9f1e8894ec （Android 群英传作者）

				cglib+dexmaker
					cglib原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。由于是通过子类来代理父类，因此不能代理被final字段修饰的方法。(Android 不能直接使用)


				Javassist For Android

				epic


2020-08-29
	Java 反射机制
		在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。
		反射是框架设计的灵魂。

		反射就是把 Java 类中的各种成分映射成一个个的 Java 对象。

		静态编译：
			在编译时确定类型，绑定对象
		动态编译：
			运行时确定类型，绑定对象
		两者的区别在于，动态编译可以最大程度地支持多态，而多态最大的意义在于降低类的耦合性，因此反射的优点就很明显了：解耦以及提高代码的灵活性。
	
		获取 Class 对象三种方式
			1. 知道具体类的情况下
				Class alunbarClass = TargetObject.class;
			2. 通过Class.forName()`传入类的路径获取
				Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
			3. 通过对象实例`instance.getClass()`获取
				Employee e;
				Class alunbarClass2 = e.getClass();
		
		示例代码见
			javaDemo->reflection->Test.java

		优缺点
			优点
				运行期类型的判断，动态加载类，提高代码灵活度。
			
			缺点
				1. 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。
				2. 安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。

		常见API
			见 javaDemo->reflection->api.txt
			类
			对象
			方法
			变量
			注解
			泛型
			动态代理
	
	枚举
		以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。

		枚举类型比较，建议使用"==",可保证编译时安全和运行时安全。

		枚举类型的属性，方法和构造函数
			可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。
			public enum PizzaStatus {
				READY (2){
            		@Override
            		public boolean isReady() {
                		return true;
            		}
        		}
			}

			this.status.isReady();

		EnumSet
			是一种专门为枚举类型所设计的 `Set` 类型。
			与`HashSet`相比，由于使用了内部位向量表示，因此它是特定 `Enum` 常量集的非常有效且紧凑的表示形式。
			它提供了类型安全的替代方法，以替代传统的基于int的“位标志”，使我们能够编写更易读和易于维护的简洁代码。
			EnumSet 是抽象类，其有两个实现：RegularEnumSet 、JumboEnumSet，选择哪一个取决于实例化时枚举中常量的数量。
			在很多场景中的枚举常量集合操作（如：取子集、增加、删除、containsAll 和 removeAll 批操作）使用 EnumSet 非常合适；如果需要迭代所有可能的常量则使用 Enum.values()。

		
		EnumMap
			EnumMap是一个专门化的映射实现，用于将枚举常量用作键。与对应的 HashMap 相比，它是一个高效紧凑的实现，并且在内部表示为一个数组。
			EnumMap<Pizza.PizzaStatus, Pizza> map;
		
		通过枚举实现一些设计模式

			单例模式
				使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。
				public enum PizzaDeliverySystemConfiguration {
					INSTANCE;
					PizzaDeliverySystemConfiguration() {
						// Initialization configuration which involves
						// overriding defaults like delivery deliveryStrategy
					}
					private PizzaDeliveryStrategy deliveryStrategy = PizzaDeliveryStrategy.NORMAL;
					
					public static PizzaDeliverySystemConfiguration getInstance() {
						return INSTANCE;
					}
					
					public PizzaDeliveryStrategy getDeliveryStrategy() {
						return deliveryStrategy;
					}
				}

				使用
					PizzaDeliveryStrategy deliveryStrategy = PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy();

			

			策略模式
				使用枚举，可以轻松完成策略模式，添加新的实现意味着只定义具有某个实现的另一个实例。
				public enum PizzaDeliveryStrategy {
					EXPRESS {
						@Override
						public void deliver(Pizza pz) {
							System.out.println("Pizza will be delivered in express mode");
						}
					},
					NORMAL {
						@Override
						public void deliver(Pizza pz) {
							System.out.println("Pizza will be delivered in normal mode");
						}
					};
					
					public abstract void deliver(Pizza pz);
				}

				public void deliver() {
					if (isDeliverable()) {
						PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy()
							.deliver(this);
						this.setStatus(PizzaStatus.DELIVERED);
					}
				}

				使用
					@Test
					public void givenPizaOrder_whenDelivered_thenPizzaGetsDeliveredAndStatusChanges() {
						Pizza pz = new Pizza();
						pz.setStatus(Pizza.PizzaStatus.READY);
						pz.deliver();
						assertTrue(pz.getStatus() == Pizza.PizzaStatus.DELIVERED);
					}
			
		枚举类型中定义属性,方法和构造函数
			public enum PinType {
				REGISTER(100000, "注册使用"),
				FORGET_PASSWORD(100001, "忘记密码使用"),
				UPDATE_PHONE_NUMBER(100002, "更新手机号码使用");

				private final int code;
				private final String message;

				PinType(int code, String message) {
					this.code = code;
					this.message = message;
				}

				public int getCode() {
					return code;
				}

				public String getMessage() {
					return message;
				}

				@Override
				public String toString() {
					return "PinType{" +
							"code=" + code +
							", message='" + message + '\'' +
							'}';
				}

			}

			使用
				System.out.println(PinType.FORGET_PASSWORD.getCode());
				System.out.println(PinType.FORGET_PASSWORD.getMessage());
				System.out.println(PinType.FORGET_PASSWORD.toString());

		
2020-08-31
	Collections

		ArrayList
			ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用 ensureCapacity 操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。
			它继承于  AbstractList ，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。
				ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。
				ArrayList 实现了 RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。
				ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，能被克隆。
				ArrayList 实现 java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。
			特点
				ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。
		
			源码：
				    public Object clone() {}	
						返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）

					扩容
						public void ensureCapacity(int minCapacity) {}
						机制
							将新容量更新为旧容量的 1.5 倍，并且与最小需要容量和最大容量进行比较。
					动态的核心机制
						System.arraycopy() 方法的使用，JVM 提供的数组拷贝实现。该方法是一个本地方法
							拷贝是浅复制。线程不安全。
							System.arrayCopy() 是对内存直接进行复制，减少了 for 循环过程中的寻址时间，从而提高了性能。
					
					System.arraycopy()和Arrays.copyOf()方法
						联系
							看两者源代码可以发现 copyOf() 内部调用了 System.arraycopy() 方法
						区别
							1. arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置
							2. copyOf()是系统自动在内部新建一个数组，并返回该数组。
			
			遍历
				迭代器遍历
					Iterator<Integer> it = arrayList.iterator();
        	 		while(it.hasNext()){
             			System.out.print(it.next() + " ");
         			}
			
			内部类
				private class Itr implements Iterator<E>
				private class ListItr extends Itr implements ListIterator<E>
				private class SubList extends AbstractList<E> implements RandomAccess
				static final class ArrayListSpliterator<E> implements Spliterator<E>  
				ArrayList有四个内部类，其中的 Itr是实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；其中的ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法，所以这也可以看出了 Iterator和ListIterator的区别: ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。

2020-09-02

	HashMap
		HashMap 主要用来存放键值对，它基于哈希表的Map接口实现。

		JDK 1.8之前
			HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。
			所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。

			扰动函数，扰动 4次。
			static int hash(int h) {
    			h ^= (h >>> 20) ^ (h >>> 12);
    			return h ^ (h >>> 7) ^ (h >>> 4);
			}
		
		JDK 1.8 之后
			jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。

			扰动函数，扰动 1 次。
			static final int hash(Object key) {
        		int h;
        		// key.hashCode()：返回散列值也就是hashcode
        		// ^ ：按位异或
        		// >>>:无符号右移，忽略符号位，空位都以0补齐
        		return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    		}

		类的属性
			// 当桶(bucket)上的结点数大于这个值时会转成红黑树
    		static final int TREEIFY_THRESHOLD = 8; 
    		// 当桶(bucket)上的结点数小于这个值时树转链表
    		static final int UNTREEIFY_THRESHOLD = 6;

			loadFactor加载因子
				loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为 0.75f 是官方给出的一个比较好的临界值。 
				给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。
			
			threshold
				threshold = capacity * loadFactor，当Size>=threshold 的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是衡量数组是否需要扩增的一个标准。

		类方法
			put 方法
				1. 如果定位到的数组位置没有元素 就直接插入
				2. 如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用 e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value) 将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。

			resize 方法
				进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。

		常用遍历
			Set<String> keys = map.keySet()
			Collection<String> values = map.values()
			Set<java.util.Map.Entry<String, String>> entrys = map.entrySet();
			for (java.util.Map.Entry<String, String> entry : entrys) {
            	System.out.println(entry.getKey() + "--" + entry.getValue());
       		}
		
		HashMap的长度为什么是 2 的幂次方
			为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。
			用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ `(n - 1) & hash`”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。
			取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。 并且采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。

	ConcurrentHashMap
		线程安全的 HashMap。CAS 尝试写入，失败，则自旋锁保证成功。
		
		CAS思想
			三个参数，一个当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false。
		
		自旋锁
			while(!tryLock()){}	，一直获取锁，获取次数超过限制，则阻塞 lock()

		Java7
			ConcruuentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。

		Java8 
			ConcruuentHashMap  使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了  Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。

	LinkedList
		实现了List接口和Deque接口的双端链表。
		LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;
		LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：
			List list = Collections.SynchronizedList(new LinkedList(...));

		api
			add
				add(E e)
				add(int index,E e)
				addAll(Collection  c)
				addAll(int index, Collection c)	
				addFirst(E e)
				addLast(E e)
			
			get
				get(int index)
				获取头节点
					getFirst(),element(),peek(),peekFirst()，其中getFirst()和element()方法将会在链表为空时，抛出异常
				获取尾节点
					getLast()、peekLast()。getLast() 方法在链表为空时，会抛出 NoSuchElementException ，而 peekLast() 则不会，只是会返回 null
				

			获取索引
				int indexOf(Object o)	//从头遍历
				int lastIndexOf(Object o)	//从尾遍历

			包含
				contains(Object o)

			删除
				remove() ,removeFirst(),pop()		//删除头节点
				removeLast(),pollLast()			//删除尾节点
					removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。
				remove(Object o)
				unlink(Node<E> x)
				remove(int index)
			
			遍历
				迭代器遍历	
					Iterator<Integer> iterator = linkedList.iterator();
        			while (iterator.hasNext()) {
            			iterator.next();
        			}

				通过pollFirst()或pollLast()来遍历LinkedList
					while (temp1.size() != 0) {
            			temp1.pollFirst();
        			}
				
				通过removeFirst()或removeLast()来遍历LinkedList
				while (temp2.size() != 0) {
            		temp2.removeFirst();
        		}	



2020-09-03

	Java 集合

		List

			ArrayList
				存储结构: Object[]数组，适用于频繁的查找工作，线程不安全，支持快速随机访问
			Vector
				存储结构：Object[]数组
			LinkedList
				共同实现List 接口和 Queue接口，存储结构是双向链表，
		

		Queue
			LinkedList
			PriorityQueue

		Dequeue
			ArrayDequeue
		

		Set
			存储的元素是无序的、不可重复的
			HashSet
				基于 HashMap 实现的，底层采用 HashMap 来保存元素；线程不安全，可以存储null值
				HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals()方法用来判断对象的相等性
			LinkedHashSet
				LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。能够按照添加的顺序遍历
			SortedSet

			TreeSet
				SortrdSet 的子类
				红黑树(自平衡的排序二叉树)，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。
		

		Map
			使用键值对（kye-value）存储，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。
			HashTable
				线程安全，因为HashTable 内部的方法基本都经过`synchronized` 修饰。不允许有null键和null值，会抛出空指针异常
			HashMap
				存储结构：
					JDK 7，数组+链表
					JDK 8，数组+链表/红黑树
				HashMap 使用键（Key）计算 Hashcode，调用 put() 向 map 中添加元素
			LinkedHashMap
				继承自 HashMap，底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
			SortedMap
			TreeMap
				SortedMap的子类


		迭代器
			Iterator 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。
			interface Iterator<E>{
				//集合中是否还有元素
    			boolean hasNext();
    			//获得集合中的下一个元素
    			E next();
			}

		线程安全性
			线程不安全集合
				Arraylist ,LinkedList,Hashmap,HashSet,TreeSet,TreeMap，PriorityQueue 都不是线程安全的

			线程安全集合
				1. ConcurrentHashMap: 可以看作是线程安全的 HashMap
				2. CopyOnWriteArrayList:可以看作是线程安全的 ArrayList，在读多写少的场合性能非常好，远远好于 Vector
				3. ConcurrentLinkedQueue:高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。
				4. BlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
				5. ConcurrentSkipListMap :跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。
				6. Vector --> ArrayList
		
		RandomAccess接口
			RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。
			在 binarySearch（) 方法中，它要判断传入的 list 是否RamdomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinarySearch()方法
			ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的。

		comparable 和 Comparator 的区别
			comparable 接口实际上是出自 java.lang 包 它有一个 compareTo(Object obj) 方法用来排序			//类对象实现的接口
			comparator 接口实际上是出自 java.util 包它有一个 compare(Object obj1, Object obj2) 方法用来排序		//额外的排序方法

			无序性
				无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。

			不重复性
				不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。

			
		快速失败(fail-fast)
			快速失败(fail-fast) 是 Java 集合的一种错误检测机制。在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。
			每当迭代器使用 `hashNext()`/`next()`遍历下一个元素之前，都会检测 `modCount` 变量是否为 `expectedModCount` 值，是的话就返回遍历；否则抛出异常，终止遍历。
		
		安全失败(fail-fast)
			采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 `ConcurrentModificationException` 异常。
		

		Arrays.asList()
			Arrays.asList()将数组转换为集合后，底层其实还是数组。
			使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。
			说明：
				asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。 Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。
			
			String[] str = new String[]{"you","wu"};
			List list = Arrays.asList(str);

			第一种情况：
				list.add("hei");	//运行时异常
			第二种情况:
				str[0]="gujin";		//那么 list.get(0) 也会随之修改
			

			传递的数组必须是对象数组，而不是基本类型。
				int[] myArray = { 1, 2, 3 };
				List myList = Arrays.asList(myArray);
				System.out.println(myList.size());//1
				System.out.println(myList.get(0));//数组地址值
				System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException
				int [] array=(int[]) myList.get(0);
				System.out.println(array[0]);//1
				当传入一个原生数据类型数组时，`Arrays.asList()` 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 List 的唯一元素就是这个数组，这也就解释了上面的代码。

				使用包装类可以解决这个问题：
					Integer[] myArray = { 1, 2, 3 };
			
			

