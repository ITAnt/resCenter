## 宏定义与结构体

### 宏定义 #define

宏定义是由源程序中的宏定义命令完成的。宏代换是由预处理程序自动完成的。宏分为有参和无参数两种。

#### 无参宏定义

##### 定义

> \#define 标识符 字符串

##### 取消定义

> \#undef 标识符

###### 注意

作为宏定义时必须十分小心，应保证在宏代换之后不发生错误。（例如：宏代换之后算数运算规则不变）

#### 带参宏定义

在宏定义中的参数称为形式参数，在宏调用中的参数称为实际参数。对带参数的宏，在调用中，不仅要宏展开，而且要用实参区代换形参。

> \#define 宏名(形参表) 字符串

###### 注意

带参宏定义中，宏名和形参表之间不能有空格出现。如

```c
#define MAX (a,b) (a>b)?a;b
```

##### 带参宏定义与自定义函数的区别

1. 在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义；而宏调用中的实参有具体的值，要用它们去代换形参，因此必须做类型说明。在带宏参数中，只是符号代换，不存在值传递的问题。
2. 在宏定义中的形参是标识符，而宏调用中的实参可以是表达式

#### 宏跟踪调试

ANSI 标准说明了五个预定义的宏名，它们分别是 \_LINE\_、\_FILE\_、\_DATE\_、\_TIME\_、\_STDC\_。

-  \_LINE\_及\_FILE\_ 宏指令打印所在行数和函数名
- \_DATE\_宏指令含有形式为 月/日/年的串，表示源文件被翻译到代码时的日期。源代码翻译到目标代码的时间作为包含在 \_TIME\_ 中，串形式为“时:分:秒”
- 如果实现是标准的，则宏 \_STDC\_ 含有十进制常量1；如果它含有任何其他数，则实现是非标准的。

#### #define 和 typedef 区别

\#define 定义“可读”的常量和一些宏语句，而 typedef 则常用来定义关键字、冗长的类型的别名。宏定义只是简单的字符串代换（原地扩展），而typedef 则不是原地扩展，它的新名字**具有一定的封装**，以致新命名的标识符具有更易定义变量的功能。

```c
typedef (int *) pINT;
```

```c
#define pINT (int *)
```

```
pINT a,b;
```

\#define 定义的 pINT ，则替换为 int * a;int b; typedef 定义的 pINT ，则替换为 int* a;int* b;

### #include

文件包含命令的功能是把指定的文件插入该命令行位置取代该命令行，从而把指定的文件和当前的源程序文件连成一个源文件。

使用尖括号表示在包含文件目录中去查找(包含目录是由用户在设置环境时设置的)，而不在源文件目录去查找；使用双引号则表示首先在当前的源文件目录中查找，若未找到才到包含目录中去查找。

###### 注意

文件包含允许嵌套，即在一个被包含的文件中又可以包含另一个文件。

### 条件编译

条件编译当然也可以用条件语句来实现，但是用条件语句将会对整个源程序进行编译，生成的目标代码程序很长，而采用条件编译，则根据条件只编译其中的程序段1或程序段2，生成的目标程序较短。

### 关于 # 和 ##

##### #

在C语言的宏中， # 的功能是将其后面的宏参数进行字符串化操作。

```c
#define EXP "exp"
printf("print EXP:#EXP\n");
```

```shell
$ print EXP:exp
```

##### ##

“##”被称为连接符，用来将两个 Token 连接为一个 Token。注意这里连接的对象是 Token 就行，而不一定是宏的变量。

### 结构体

##### 引用结构体变量成员

- 结构体变量名.成员名，如 "stu1.name"
- 结构体指针变量->成员名，如“ps->name”
- (*结构体指针变量).成员名，如(\*ps).name
- 结构体变量数组名.成员名，如"stu[0].name"

#### 内存对齐

结构体内存对齐，是为了在空间与复杂度上达到平衡的一种技术手段。基本是保证结构体长度是原始成员最长分配的整数倍即可。

系统默认的对齐规则追求的至少有两点：

1. 变量的最高效加工
2. 达到1的最少空间

##### 内存对齐正式原则

- 数据类型自身的对齐值：基本数据类型的自身对齐值，等于“sizeof(基本数据类型)”
- 指定对齐值："#pragma pack(value)"时的指定对齐值 value
- 结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值
- 数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小的那个值

有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐 N 表示“对齐在 N上”，也就是说该数据的“存放起始地址 % N =0”，而数据结构中的数据变量都是按定义的先后顺序来排放的，第一个数据变量的起始地址就是数据结构的起始地址。

``` c
#pragma pack(2)				//指定按 2 字节对齐
#pragma pack() 				//取消指定对齐，恢复默认对齐
```

###### 函数说明

> \#pragma pack( [show] | [push | pop] [, identifier], n )

1. pack提供数据声明级别的控制，对定义不起作用；
2. 调用pack时不指定参数，n将被设成默认值；
3. 一旦改变数据类型的alignment，直接效果就是占用memory的减少，但是performance会下降。

###### 参数说明

- show：可选参数；显示当前packing aligment的字节数，以warning message的形式被显示；
- push：可选参数；将当前指定的packing alignment数值进行压栈操作，这里的栈是the internal compiler stack，同时设置当前的packing alignment为n；如果n没有指定，则将当前的packing alignment数值压栈；
- pop：可选参数；从internal compiler stack中删除最顶端的record；如果没有指定n，则当前栈顶record即为新的packing alignment数值；如果指定了n，则n将成为新的packing aligment数值；如果指定了identifier，则internal compiler stack中的record都将被pop直到identifier被找到，然后pop出identitier，同时设置packing alignment数值为当前栈顶的record；如果指定的identifier并不存在于internal compiler stack，则pop操作被忽略；
- identifier：可选参数；当同push一起使用时，赋予当前被压入栈中的record一个名称；当同pop一起使用时，从internal compiler stack中pop出所有的record直到identifier被pop出，如果identifier没有被找到，则忽略pop操作；
- n：可选参数；指定packing的数值，以字节为单位；缺省数值是8，合法的数值分别是1、2、4、8、16。

### 位段

位段(bit-field) 是以位为单位来定义结构体(或联合体)中的成员变量所占的空间，含有位段的结构体（联合体）称为位段结构。

> type [var]:digis;

type 只能是 int、unsigned int 、signed int 三种类型（int 型不能表示负数视编译器而定）。

var 是可选参数，即可以省略。

digits 表示该位段所占的二进制位数

##### 使用

- 位段的类型只能是 int、unsigned int、signed int 三种类型，不能是 char 型或者浮点型
- 位段占的二进制位数不能超过该基本类型所能表示的最大位数，比如在 vc 中 int 是占 4个字节，那么最多只能是32 位
- 无名位段不能被访问，但是会占据空间
- 不能对位段进行取地址操作
- 若位段占的二进制位数位0，则这个位段必须是无名位段，下一个位段从下一个位段存储单元开始存放
- 若位段出现在表达式中，则会自动进行整型升级，自动转换位 int 型或者 unsigned int
- 对位段赋值时，最好不要超过位段所能表示的最大范围，否则可能会造成意想不到的结果
- 位段不能出现数组的形式

##### 位段的存储方式

对于位段结构，编译器会自动进行存储空间的优化，主要的原则位：

1. 如果一个位段存储单元能够存储位段结构中的所有成员，那么位段结构中的所有成员只能放在一个位段存储单元中，不能放在两个位段存储单元中；如果一个位段存储单元不能容纳位段结构中的所有成员，那么剩余的位段从下一个位段存储单元开始存放（在vc 中位段存储单元的大小是 4 字节）
2. 如果一个位段结构中只有一个占有 0 位的无名位段，则只占 1或 0 字节的空间（C语言中是占0字节，而C++中占1字节）；否则其他任何情况下，一个位段结构所占的空间至少是一个位段存储单元的大小。