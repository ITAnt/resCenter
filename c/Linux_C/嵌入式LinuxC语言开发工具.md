## 嵌入式LinuxC 语言开发工具



### 嵌入式编译器

**GCC**

- GCC可以为 x86、ARM、MIPS等不同体系结构的硬件平台编译程序
- GCC可以编译C、C++、Pascal、Java等数十种高级语言

#### gcc 命令常用选项及工作流程

> gcc [选项] [文件名] [选项] [文件名]

##### gcc编译选项

1. 总体选项：用于控制编译的整个流程，常用选项如下：

   > -c:			对源文件进行编译或汇编
   >
   > -E:			对源文件进行预处理
   >
   > -S:			对源文件进行编译
   >
   > -o file:	 输出目标文件file
   >
   > -v:			显示编译阶段的命令

2. 语言选项：用于支持各种版本的C语言程序，常用选项如下：

   > -ansi:		支持符合ANSI标准的 C程序

3. 警告选项：用于控制编译过程中产生的各种警告信息，常用选项如下：

   > -W:					屏蔽所有的警告信息
   >
   > -Wall:				显示所有类型的警告信息
   >
   > -Werror:		  出现任何警告信息就停止编译

4. 调试选项：用于控制调试信息，常用选项如下：

   > -g: 				产生调试信息

5. 优化选项：用于对目标文件进行优化，常用选项如下：

   > -O1:				对目标文件的性能进行优化
   >
   > -O2:				在O1的基础上进一步优化，提高目标文件的运行性能
   >
   > -O3:				在-O2的基础上进一步优化，支持函数集成优化
   >
   > -O0:				不进行优化

6. 连接器选项：用于控制链接过程，常用选项如下：

   > -static:				使用静态链接
   >
   > -llibrary:			 链接library函数库文件
   >
   > -L dir:				 指定连接器的搜索目录dir
   >
   > -shared:			 生成共享文件

7. 目录选项：用于指定编译器的文件搜索目录，常用选项如下：

   > -Idir:					指定头文件的搜索目录dir
   >
   > -Ldir:				   指定搜索目录dir

##### gcc 编译过程

> 1. 预编译(Pre-Processing)
> 2. 编译(Compiling)
> 3. 汇编(Assembling)
> 4. 链接(Linking)

###### 预处理阶段

由于在 test.c 中使用了头文件 stdio.h，所以 GCC在编译时首先要把头文件 stdio.h 中的内容加载到 test.c 中的首部

> gcc -E test.c -o test.i

参数E告诉 gcc命令只进行预编译，不做其他处理；参数 o 用来指明输出的文件名为 test.i。

###### 编译阶段

> 高级编程语言编译阶段必须实现这三个步骤：
>
> 	1. 词法分析：主要负责检查关键字、标识符等是否正确
>  	2. 语法分析：主要负责检查程序中语句的语法是否正确
>  	3. 语义分析：主要负责检查程序中语句的逻辑意义是否正确

> gcc -S test.i -o test.s

###### 汇编阶段

把汇编程序翻译成CPU可以识别的二进制文件，该文件又称为目标文件。

> gcc -c test.s -o test.o

链接阶段

链接阶段的任务就是把程序中所有的目标文件和所需的库文件都链接在一起，最终生成一个可以直接运行的文件，称为可执行文件。

> gcc -test.o -o test

**备注：**

gcc 命令生成的可执行文件的有三种格式：a.out（Assembler and Link editor output）、COFF(Common object file format)、ELF(Executable and linkable format)，其中，a.out 和 COFF格式都是比较老的格式，现在Linux平台上可执行文件的主流格式是 ELF。

##### 库的使用

函数库的使用方式分为静态链接和动态链接两种。

###### 静态链接

静态链接是指编译系统在链接阶段把程序的目标文件和所需的函数库文件链接在一起，这样生成的可执行文件就可以在没有函数库的情况下运行。

使用静态链接方式产生的可执行文件体积较大，但运行效率比较高。

可被静态链接的函数库称为静态库。

###### 动态库链接

动态库链接是指编译系统在链接阶段并不把目标文件和函数库文件链接在一起，而是等到程序在运行过程中需要使用时才链接函数库。

使用动态链接库产生的可执行文件由于没有库文件，所以体积较小。但由于需要动态加载函数库，所以运行效率要低一点。

可以被动态链接的函数库称为动态库，或者共享库。

**备注：**

多个源文件都需要调用函数库，那么应该选择动态链接库的方式。

只有少数源文件需要调用函数库时，应该选择静态链接的方式。

glibc 包含了大量的函数库，其中libc 时最基本的函数库，每个C程序都需要使用libc库。常用的还有数学库 libm、加密库 libcrypt、POSIX线程库libpthread、网络服务库libnsl、IEEE浮点运算库libieee等。

链接数学库 libm:

> gcc test.c -o test -lm

使用静态链接库方式对程序进行编译

> gcc -static test.c -o test

statically linked表明 test文件使用了静态链接库。

### 嵌入式调试器

> gcc -g test.c -o test

对test.c 进行编译，其中参数 g 的作用是把调试信息加入生成的 test 可执行文件中，否则GDB就无法对 test 进行调试。

> gdb test

启动GDB对test进行调试。GDB首先显示了版本信息和库信息。随后GDB停留在符号“(gdb)”处等待用户输入调试命令。

1. 查看源文件

   > l

   list的缩写，可以查看所有的代码函数。GDB以10行为单位进行显示。再次运行一次命令"l"就会显示下 10 行代码。

2. 设置断点

   > b 7

   命令b (breakpoint的缩写)进行断点的设置。命令b 在程序的第7行处设置了第一个断点，并显示了该断点在内存中的物理地址。

3. 查看断点的情况

   > info b

   "info b"可查看所有的断点情况

4. 运行程序

   > r

   命令“r(run的缩写)”运行程序。GDB默认从代码的首行开始运行（也可以通过“r 行数“的方式让程序从指定行树开始运行）。如果程序有断点，则程序会在断点行数的前一行暂停运行。

5. 查看变量值

   > p n

   "p 变量名"（print的缩写）查看当前变量n的值。

6. 继续运行程序

   > c

   命令c(continuing) 让程序继续往下运行。

7. 单步运行

  > s

  在GDB中可以通过命令“s”（step的缩写）和"n"（next的缩写）让程序一步一步地往下运行。其中s 可以在发生函数调用时进入函数内部运行，而n不会进入函数内部运行

### 工程管理器

GCC 提供了半自动化的工程管理器 Make。所谓半自动化是指在使用工程管理器前需要人工编写的编译规则，所有的编译规则都保存在Makefile文件中，全自动化的工程管理器在编译程序前会自动生成Makefile文件。

#### 优点

- 使用方便

- 调试效率高：

  Make会检查每个源文件的修改时间（时戳）。只有在上次编译之后被修改的源文件才会在接下来的编译过程中被编译和链接，这样就能避免多余的编译工作量。

#### Makefile

Makefile文件由以下三项基本内容组成：

- 需要生成的目标文件(target file)
- 生成目标文件所需要的依赖文件(dependency file)
- 生成目标文件的编译规则命令行(command)

> target file:dependency file
>
> command

Makefile规定在书写 command命令行前必须加一个 \<Tab\>键。

Make工程管理在编译程序时会检查每个依赖文件的时间戳，一旦发现某个依赖文件的时间戳比目标文件更新，就会执行目标文件的规则命令来重新生成目标文件。这个过程称为目标文件的依赖规则检查。依赖规则检查时Make工程管理器的最核心的工作任务之一。

```makefile
test:a.o b.o
	cc -o test a.o b.o
a.o:a.c b.h
	cc -c a.c
b.o:b.c
	cc -c b.c
```

#### 变量

Makefile中变量的命名可以使用字符、数字和下划线，但要注意变量名对大小写是敏感的。

> $(变量名)

```makefile
obj=a.o b.o
test : $(obj)
```

1. :=

   ```makefile
   a1:=a.o
   a2:=$(a1) b.o
   ```

    变量 a2 的值是 a.o b.o

   ```makefile
   a1:=$(a2) b.o
   a2:=a.o
   ```

   变量a1的值是 b.o，而不是"a.o b.o"。也就是说前面的变量不能通过后面的变量来定义。

2. +=  追加变量

   ```makefile
   a1=a.o
   a1+=b.o
   ```

   a1的值是"a.o b.o"。

3. ?=

   如果变量已经在前面定义过了，那么后面的定义就无效了。

   ```makefile
   a1:=a.o
   a1?=b.o
   ```

   a1的值就是 a.o

#### 自动推导

Make工程管理器提供了自动推导的功能。自动推导功能默认每个目标文件都有一个与之对应的依赖文件。例如，a.o 文件有依赖文件 a.c 与之对应，这样在Makefile中就不需要指定与目标文件对应的依赖文件名了。此外，自动推导功能还能推导出与目标文件对应的基本编译规则命令。例如，a.o 文件的规则命令为 “gcc -c -o a.c”

```makefile
obj = a.o b.o
test :$(obj)
	cc -o test $(obj)
a.o:b.h
```

结果为：

```makefile
cc -c -o a.o a.c
cc -c -o b.o b.c
cc -o test a.o b.o
```

##### 伪目标

伪目标不是真正的目标文件，只是一个符号。为了不和真实的目标文件混淆，最好使用".PHONY"对伪目标进行标识。例如：

```makefile
obj= a.o b.o
.PHONY:all
all:test $(obj)

test:$(obj)
	cc -o test $(obj)

.PHONY:clean
clean:
	rm -rf test $(obj)

test_dir=/home/t_d
.PHONY:install
install:
	mkdir $(test_dir)
	cp test $(test_dir)

.PHONY:uninstall
uninstall:
	rm -rf $(test_dir)
```

在Makefile文件中，伪目标是非常有用的。例如，在递归编译、并行编译等场合中，使用伪目标可以方便地控制编译过程。

#### 文件查找

- VPATH

  VPATH 是一个特殊变量，Make在当前路径找不到源文件的情况下就会自动到 VPATH 中指定的路径中去寻找。

  ```makefile
  VPATH =目录1:目录2:目录3
  ```

- vpath

  vpath不是变量而是关键字，其作用和VPATH类似，但使用方式更加灵活。

  > vpath 模式 目录1:目录2

  ```makefile
  vpath %.c /a:/b
  ```

#### 嵌套执行

把Makefile分解成多个子 Makefile，并放置到程序的每个子目录中，每个子Makefile文件负责所在目录下源文件的编译工作。

> cd 子目录  && $(MAKE)
>
> or 
>
> $(MAKE) -c 子目录  

如：

```
b.o:b.c
	cd b && make
```

总控Makefile中的变量可以通过“export”变量的方式传递到各级子 Makefile中，但不会覆盖子 Makefile 中的变量。也可以通过"unexport"变量的方式不让变量传递到各级子 Makefile中。

#### 条件判断

> 条件表达式
>
> 如果真执行的文本段
>
> else
>
> 如果假执行的文本段
>
> endif

ifeq(参数1，参数2)：

​	比较参数1 和参数2 的值是否相同，相同为真，相异为假。

ifneq(参数1，参数2)：

​	比较参数1 和参数2的值是否相同，相同为假，相异为真。

ifdef(参数)：

​	参数非空为真，空为假

ifndef(参数)：

​	参数空为真，非空为假。	

#### 函数

函数用符号 $进行标识，其使用格式为

> $(函数名 参数，参数...)

其中函数名和参数之间用空格隔开，参数与参数之间用逗号隔开。

1. subst

   > $(subset 参数1，参数2，参数3)

   功能：把参数3 中的参数1 替换成参数2。

   返回值：被替换后的参数3。

2. patsubst

   > $(patsubset 模式参数，参数1，参数2)

   功能：把参数2中符合模式参数的单词（单词是指参数中被空格隔开的字符串）替换参数1

   返回值：被替换后的参数2

3. wildcard

   > $(wildcard 模式参数)

   功能：列出当前目录下所有符合模式参数的文件名。

   返回值：当前目录下所有符合模式参数的文件名

4. strip

   > $(strip 参数)

   功能：去掉参数开头和结尾的空格

   返回值：被去掉空格的参数

5. findstring

   > $(findstring 参数1，参数2)

   功能：在参数2中查找参数1

   返回值：如果找到返回参数1，如果没找到返回空

6. filter

   > $(filter 模式参数，参数1)

   功能：从参数1中筛选出符合模式参数的字符串。

   返回值：符合参数模式的字符串

7. addsuffix

   > $(addsuffix 参数1，参数2)

   功能：在参数2中的每个单词加上后缀参数1

   返回值：加上后缀的所有单词

8. addprefix

   > $(addprefix 参数1,参数2)

   功能：在参数2中的每个单词加上前缀参数1。

   返回值：加上前缀的所有单词

9. foreach

   > $(foreach 变量参数,参数1,表达式)

   功能：循环取出参数1 中的单词赋给变量参数，然后运行表达式。

   返回值：表达式的运行结果

10. call

    > $(call 变量参数,参数...)

    功能：循环把参数依次赋值给变量参数中的$(1)、\$(2)....

    返回值：赋值后的变量值

11. if

    > $(if 条件参数,执行参数)

    功能：如果条件参数为非空，运行执行参数部分

    返回值：条件参数非空，返回执行参数部分

12. dir

    > $(dir 参数)

    功能：从参数中取出目录部分

    返回值：目录部分

13. error

    > $(error 参数)

    功能：停止"Make"运行并显示参数

    返回值：参数

14. warning

    > $(warning 参数)

    功能：“Make”运行时显示参数

    返回值：参数