## 多线程

线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

一个线程包含以下内容：

- 一个指向当前被执行指令的指令指针
- 一个栈
- 一个寄存器值的集合，定义了一部分描述正在执行线程的处理器状态的值
- 一个私有的数据区

所有这些元素都归于线程执行上下文的名下。处于同一进程中的所有线程都可以访问该进程所包含的地址空间，当然也包含存储在该空间中的所有资源。



#### 优点

- 多线程技术使程序的响应速度更快，因为用户界面可以在进行其他工作的同时一直处于活动状态
- 当前没有进行处理的任务时可以将处理器时间让给其他任务
- 占用大量处理时间的任务可以定期将处理器时间让给其他任务
- 可以随时停止任务
- 可以分别设置各个任务的优先级及优化性能

#### 缺点

- 等候使用共享资源时会使程序的运行速度变慢，这些共享资源主要是独占性的资源，如打印机等
- 对线程进行管理要求额外的 CPU 开销。线程的使用会给系统带来上下文切换的额外负担，当这种负担超过一定程度时，多线程的特点主要表现在其缺点上，比如用独立的线程来更新数组内每个元素
- 线程的死锁。即较长时间的等待或资源竞争，以及死锁等多线程症状
- 对公有变量的同时读或写

### 实现

多线程开发的最基本概念主要包含三点：线程、互斥锁、条件。

线程包含线程创建、退出、等待

互斥锁包含创建、销毁、加锁和解锁

条件操作有创建、销毁、触发、广播和等待

因为 pthread 的库不是 Linux 系统的库，所以在进行编译的时候要加上 "-lpthread"。例如：

> gcc filename -lpthread

#### 线程

##### 创建

pthread_create 函数用于创建线程

> \#include <pthread.h>
>
> int pthread_create(pthread_t *restrict tidp,const pthread_attr_t *restrict attr,void *(*start_rtn)(void),void *restruct arg)

###### 函数说明

- pthread_t *restrict tidp：要创建的线程的线程ID指针
- const pthread_attr_t *restrict attr：创建线程时的线程属性
- void* (start_rtn)(void)：返回值是 void 类型的指针函数
- void *restrict arg：start_rtn 的行参

###### 返回值

调用成功完成后返回0，其他的值都表现出现错误。如果检测到以下任一情况，pthread_create() 将失败并返回相应的值。

- EAGAIN：超出了系统限制，如创建的线程太多
- EPERM：调用者没有适当的权限设置所需的参数或安排调度策略
- EINVAL：描述：tattr 的值无效（设置的属性有问题）

默认属性：绑定，非分离，继承创建者线程中定义的调度策略

###### 示例

```c
#include <stdio.h>
#include <pthread.h>

void *myThread1(void)
{
    int i;
    for(i=0;i<100;i++)
    {
        printf("This is the 1st pthread,created by zieckey.\n");
        sleep(1);//Let this thread to sleep 1 second,and then continue to run
    }
}

void *myThread2(void)
{
    int i;
    for(i=0;i<100;i++)
    {
        printf("This is the 2st pthread,created by zieckey.\n");
        sleep(1);
    }
}

int main()
{
    int i=0,ret =0;
    pthread_t id1,id2;
    
    //创建线程
    ret = pthread_create(&id1,NULL,(void *)myThread1,NULL);
    if(ret)
    {
        printf("Create pthread error!\n");
        return 1;
    }
    
    //创建线程2
    ret = pthread_create(&id2,NULL,(void *)myThread2,NULL);
    if(ret)
    {
        printf("Create pthread error\n");
        return 1;
    }
    
    pthread_join(id1,NULL);
    pthread_join(id2,NULL);		//等待线程执行完成，然后退出主线程
}
```

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void *create(void *arg)		//接收参数
{
    int *num;
    num = (int *)arg;
    printf("create parameter is %d\n",*num);
    return (void *)0;
}

int main(int argc,char *argv[])
{
    pthread_t tidp;
    int error;
    int test =4;
    int *attr = &test;
    
    error = pthread_create(&tidp,NULL,create,(void *)attr);
    if(error)
    {
        printf("pthread_create is created is not created...\n");
        return -1;
    }
    sleep(1);
    printf("pthread_create is created...\n");
    return 0;
}
```

##### 终止线程

pthread_exit 函数用于终止线程

> \#include <pthread.h>
>
> void pthread_exit(void *retval)

###### 函数说明

使用函数 pthread_exit 退出线程，这是线程的主动行为；由于一个进程中的多个线程是共享数据段的，因此通常在线程退出之后，退出的线程所占用的资源并不会随着线程的终止而得到释放，但是可以用 pthread_join() 函数来同步并释放资源。

###### 返回值

 pthread_exit() 调用线程的返回值，可由其他函数如 pthread_join() 来检索获取。

###### 注意

线程退出的三种方式：

- 线程从执行函数返回，返回值是线程的退出码
- 线程被同一进程的其他线程取消
- 调用 pthread_exit() 函数退出

有一个重要的特殊情况，即当初始线程(即调用 main() 的线程)从main() 调用返回时或调用 exit() 时，整个进程及其所有的线程将终止。因此，一定要确保初始线程不会从 main() 过早的返回，在其他线程调用 exit() 也会终止真整个进程。

注意，如果主线程仅仅调用了 pthread_exit，则仅主线程本身终止，进程及进程内的其他线程将继续存在。所有线程都已终止时，进程也将终止。

##### 等待线程终止

pthread_join() 函数用于等待线程。

> \#include <pthread.h>
>
> int prhread_join(thread_t tid,void **status)

###### 函数说明

参数 tid 指定要等待的线程 ID，指定的线程必须位于当前的进程中，而且不得是分离线程。当参数 status 不是 NULL 时，status 指向某个位置，在 pthread_join() 成功返回时，将该位置设置为已终止线程的退出状态。

###### 返回值

调用成功完成后，pthread_join() 将返回0，其他任何返回值都表示出现了错误。如果检测到以下任一情况，pthread_join() 将失败并返回相应的值。

- ESRCH：没有找到与给定的线程ID 相对应的线程
- EDEADLK：将出现死锁，如一个线程等待其本身，或者线程 A 和线程 B互相等待
- EINVAL：与给定的线程ID相对应的线程是分离线程

###### 注

如果多个线程等待同一个线程终止，则所有等待线程将一直等到目标线程终止，然后，一个等待线程成功返回，其余的等待线程将失败并返回 ESRCH 错误。

pthread_join() 仅适用于非分离的目标线程。如果没有必要等待特定线程终止之后才进行其他处理，则应当将该线程分离。

###### pthread_exit() 和pthread_join() 区别

- 线程自己运行结束，或者调用 pthread_exit() 结束，线程都会释放自己独有的空间资源
- 如果线程是非分离的，线程会保留线程ID号，直到其他线程通过“joining”这个线程确认其已死亡。join的结果是 joining 线程得到已终止线程的退出状态，已终止的线程将消失
- 如果线程是分离的，不需要使用 pthread_exit()，线程自己运行结束，就会释放所有资源（包括线程ID）
- 子线程最终一定要使用 pthread_join() 或者设置为分离状态来结束线程，否则线程的资源不会被完全释放（使用取消线程功能也不能完全释放）
- 主线程运行 pthread_exit()，会结束主线程，但不会结束子线程
- 主线程结束，则整个程序结束，所以主线程最好要使用 join 等待子线程运行结束，使用 join 一个线程可以等待多个线程结束
- 使用 join 的线程将会阻塞，直到被 join 的线程结束，join函数返回，但是它对被 join 的线程运行没有影响
- 如果子线程使用 exit() 则可以结束整个进程

##### 线程属性

只需要创建并填充一个 pthread_attr_t 类型的线程属性对象 ATTR，并将其作为第二个参数传递给 pthread_create 就可以指定新创建线程的属性。

仅当创建新线程的时候线程属性对象才被参考，同一个线程对象可用于创建多个线程。在 pthread_create 之后修改一个线程对象并不会修改之前创建的线程属性。

```c
typedef struct
{
    int detachstate;		//线程的分离状态
    int schedpolicy;		//线程调度策略
    struct sched_param	schedparam;		//线程的调度参数
    int inheritsched;		//线程的继承性
    int scope;				//线程的作用域
    size_t guardsize;		//线程栈末尾的警戒缓冲区大小
    int stackaddr_set;
    void * stackaddr;		//线程栈的位置
    size_t stacksize;		//线程栈的大小
}pthread_attr_t;
```

###### 线程属性初始化

pthread_attr_init() 函数用于线程属性初始化，pthread_arrt_destroy 函数用于去除初始化。

> \#include <pthread.h>
>
> int pthread_attr_init(pthread_attr_t *attr)

attr：线程属性变量，对线程属性初始化

返回值：若成功返回0，若失败返回-1

> \#include <pthread.h>
>
> int pthread_arrt_destroy(pthread_attr_t *attr)

attr：线程属性变量，对线程属性去除初始化

返回值：若成功返回 0，若失败返回-1

###### 线程分离

在任何一个时间点上，线程都是可结合(Joinable)或者分离的(Detached)。

默认情况下线程是非分离状态的，在这种情况下，原有的线程等待创建的线程结束。只有当 pthread_join() 函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。

如果我们在创建线程时不需要了解线程的终止状态，则可以 pthread_attr_t 结构中的 detachstate 线程属性，让线程以分离状态启动。

pthread_attr_getdetachstate 函数用于获取线程的分离状态属性，pthread_attr_setdetachstate 函数用于修改线程的分离状态属性。

> \#include <pthread.h>
>
> int pthread_attr_getdetachstate(const pthread_attr_t *attr,int *detachstate)

**函数说明**

- attr：线程属性变量
- detachstate：线程的分离状态属性

**返回值**

若成功返回0，若失败返回 -1。

> \#include <pthread.h>
>
> int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate)

**函数说明**

- attr：线程属性变量
- detachstate：线程的分离状态属性
  - PTHREAD_CREATE_DETACHED，以分离状态启动线程
  - PTHREAD_CREATE_JOINABLE，正常启动线程

**返回值**

若成功返回0，若失败返回 -1。

**注意**

如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在 pthread_create 函数返回之前就终止了，它终止以后 就可能将线程号和系统资源移交给其他线程使用，这样调用 pthread_create() 的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用 pthread_cond_timewait() 函数，让这个线程等待一会儿，留出足够的时间让函数 pthread_create() 返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如 wait() 之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。

###### 线程的继承性



###### 线程的调度策略



线程的调度参数