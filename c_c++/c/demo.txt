内容节点
    -结构体元素
    -内存空间分配
    -二叉树
    -进程
    -大小端
    -图及其图顶点访问
    -hash_table
    -链表
    -分治法排序
    -堆排序
    
    详细内容：
        typedef struct JWImplementationArray{
            int size;
            int capacity;
            int *data;
        } JArray;

        malloc()
        realloc()
        memmove()
        assert()    //断言


        bst binary search

        typedef struct bst_node_t{
            int value;
            struct bst_node_t* left;
            struct bst_node_t* right;
        } bst_node;

        malloc()    //节点分配
        递归调用

        //大小端获取
        bool is_little_endian(){
            union{
                short number;
                char oneByte;
            } endianTest;

            endianTest.number = 1;
            return endianTest.oneByte;
        }


        int pid = fork();   //创建一个进程

        typedef struct{
            int v;  //vertex count，顶点数
            int e;  //edge count，边数

            struct neighbors{
                int length;
                int capacity;
                int list[];
            }* adjacency_list[];
        } UndirectedGraph;      //有向或无向图结构，无向图的关联性：两边都要添加

        /*
        *   访问图的元素，通过一个数组来标识是否被访问过
        */
        void ugraph_dfs(UndirectedGraph *g,int visited[],const int vertex)
        {
            visited[vertex] = 1;    //访问的顶点
            printf("%d -> ",vertex);

            for(int e=0;e<g->adjacency_list[vertex]->length;++e)
            {
                int u = g->adjacency_list[vertex]->list[e];
                if(visited[u] == 0) //没有被访问过的点
                {
                    ugraph_dfs(g,visited,u);
                }
            }
        }
        
        /*
        * hash table 哈希表
        */
        typedef struct KeyValue{
    		char* key;
			char* value;
			struct KeyValue* next;  //链表，解决key 冲突的问题
		}key_value;
			
		typedef struct HashTable{
			key_value** data;   //表结构，类似数组的形式
			int size;
		}hash_table;

        /**
        *   link 链表
        */
        typedef struct Node{
            int val;
            struct Node *next;
        } node_t;


        /**
        *   分治法排序
        */
        void merge(int numbers[],int low,int mid,int high)  //0 14 29
        {
            int b[high-low-1];
            int i=low;
            int j= mid+1;
            int k=0;

            //merge items from list in order
            while(i<= mid && j<= high)
            {
                if(numbers[i] <= numbers[j])
                {
                    b[k++] = numbers[i++];
                }else{
                    b[k++] = numbers[j++];
                }
            }

            //copy the remaining items to tmp JWImplementationArray
            while(i<= mid) b[k++] = numbers[i++];
            while(j<high) b[k++] = numbers[j++];

            --k;
            while(k>=0){
                numbers[low+k] =b[k];
                --k;
            }
        }   
        /**
        *   分治递归排序
        */
        void merge_sort(int numbers[],int low,int high)     //low:0  high:29
        {
            if(low < high)
            {
                int mid = (low+high)/2;
                merge_sort(numbers,low,mid);
                merge_sort(numbers,mid+1,high);
                merge_sort(numbers,low,mid,high);
            }
        }

        /**
        *   堆排序
        */
        typedef struct MaxHeap{
            int size;
            int elements[kQueueCapacity+1];
            int capacity;
        } MaxHeap;

        void shift_up(MaxHeap* heap,int i)
        {
            int temp;
            int parent;
            while(i>1)
            {
                parent = i/2;
                if(heap->elements[parent] < heap->elements[i])
                {
                    temp = heap->elements[i];
                    heap->elements[i] = heap->elements[parent];
                    heap->elements[parent] = temp;
                }
                i = parent;
            }
        }

        void sift_down(MaxHeap* heap,int index)
        {
            int i= index;
            int swap_index;

            while(i*2<=heap->size)
            {
                int left_child_index = 2*i;
                int right_child_index = 2*i+1;
                bool has_left = (left_child_index <= heap->size);
                bool has_right = (right_child_index <= heap->size);

                if(has_left && has_right)
                {
                    int left_child_value = heap->elements[left_child_index];
                    int right_child_value = heap->elements[right_child_index];

                    if(left_child_value > right_child_value)
                    {
                        swap_index = left_child_index;
                    }else{
                        swap_index = right_child_index;
                    }
                }else if(has_left)
                {
                    swap_index = left_child_index;
                }else if(has_right)
                {
                    swap_index = right_child_index;
                }else{
                    break;
                }

                if(heap->elements[swap_index] > heap->elements[i])
                {
                    int temp = heap->elements[i];
                    heap->elements[i] = heap->elements[swap_index];
                    heap->elements[swap_index]= temp;

                    i = swap_index;
                }else{
                    break;
                }
            }
        }


        void percolate_down(int* numbers,int count,int index)
        {
            int i= index;
            int swap_index;

            //no children - nothing to do
            //one child - swap if needed
            //2 children -swap with larger if needed

            while((i*2)+1 < count)
            {
                int left_child_index = 2*i+1;
                int right_child_index = 2*i+2;
                bool has_left = (left_child_index < count);
                bool has_right = (right_child_index < count);

                if(has_left && has_right){
                    int left_child_value = numbers[left_child_index];
                    int right_child_value = numbers[right_child_index];

                    if(left_child_value > right_child_value){
                        swap_index = left_child_index;
                    }else{
                        swap_index = right_child_index;
                    }
                }else if(has_left){
                    swap_index = left_child_index;
                }else if(has_right){
                    swap_index = right_child_index;
                }else{
                    break;
                }

                if(numbers[swap_index] > numbers[i])
                {
                    int temp = numbers[i];
                    numbers[i] = numbers[swap_index];
                    numbers[swap_index] = temp;
                    i = swap_index;
                }else{
                    break;
                }
            }
        }
        void heapify(int* numbers,int count){
            for(int i=count/2-1;i>=0;--i){
                percolate_down(numbers,count,i);
            }
        }

        void heap_sort(int *numbers,int count)
        {
            int temp;
            heapify(numbers,count);
            for(int i=count-1;i>0;--i)
            {
                temp = numbers[0];
                numbers[0] = numbers[i];
                numbers[i] = temp;
                percolate_down(numbers,i,0);
            }
        }


