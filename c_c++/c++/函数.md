# 函数

### const 形参和实参

顶层const作用于对象本身：

```c++
const int ci = 42；	//不能改变ci，const是顶层的
int i = ci;		//正确：当拷贝ci时，忽略了它的顶层const
int * const p= &i;	//const是顶层的，不能给p赋值
*p = 0;		//正确：通过p改变对象的内容是允许的，现在i变成了0
```

和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的：

```c++
void fcn(const int i){	//fcn 能够读取 i,但是不能向 i写值}
```

```c++
void fcn（const int i）{/* fcn能够读取i，但是不能向i写值*/}
void fcn（int i）{/*...*/} 	//错误：重复定义了fcn（int）
```

在 C++语言中，允许我们定义若干具有相同名字的函数，不过前提是**不同函数的形参列表应该有明显的区别**。因为**顶层const被忽略掉了**，所以在上面的代码中传入两个fcn函数的参数可以完全一样。因此第二个fcn是错误的，尽管形式上有差异，但实际上它的形参和第一个fcn的形参没什么不同。

#### 指针或引用形参与 const

我们可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。

```c++
int i = 42;
const int *cp =&i；	//正确：但是cp不能改变i
constint&r=i；	//正确：但是r不能改变i
const int &r2 = 42; 	// E:(2.4.1 ,55 )
int *p = cp;	//错误：p的类型和cp的类型不匹配
int &r3 = r;	//错误：r3的类型和r的类型不匹配
int &r4 = 42;	//错误：不能用字面值初始化一个非常量引用
```

将同样的初始化规则应用到参数传递上可得如下形式：

```c++
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i);	//调用形参类型是int*的reset函数
reset (&ci);	//错误：不能用指向const int对象的指针初始化int*
reset(i);	//调用形参类型是int&的reset函数
reset(ci);	//错误：不能把普通引用绑定到const对象ci上
reset(42);	//错误：不能把普通应用绑定到字面值上
reset(ctr);//错误：类型不匹配，ctr是无符号类型
//正确：find_char的第一个形参是对常量的引用
find_char("Hello World!", 'o', ctr);
```

### 数组形参

```c++
//尽管形式不同，但这三个print函数是等价的
//每个函数都有一个const int*类型的形参
void print (const int*);
void print (const int[]);	//可以看出来，函数的意图是作用于一个数组
void print (const int [10]);	//这里的维度表示我们期望数组含有多少元素，实际不一定
```

尽管表现形式不同，但上面的三个函数是等价的：每个函数的唯一形参都是const int*类型的。当编译器处理对print函数的调用时，只检查传入的参数是否是const int\*

因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术。

- 使用标记指定数组长度
- 使用标准库规范
- 显式传递一个表示数组大小的形参

#### 数组引用形参

```c++
//正确：形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10])
{
	for (auto elem:arr)
	cout <<elem <<endl;
}
```

f(int (&arr)[10]）	//正确：arr是具有10个整数的整型数组的引用

#### 传递多维数组

再一次强调，\*matrix两端的括号必不可少：
int \*matrix[10];	//10个指针构成的数组
int(\*matrix)10:	//指向令有10个整数的数组的指针

### main: 处理命令行选项

当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。

### 含有可变形参的函数

C++11新标准提供了两种主要的方法：

- 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；

- 如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板

#### initializer_list 形参

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中，它提供的操作如下表所示。

| 函数                               | 函数说明                                                     |
| :--------------------------------- | ------------------------------------------------------------ |
| initializer_list<T> lst;           | 默认初始化；T类型元素的空列表                                |
| initializer_list<T> lst{a,b,c...}; | lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const |
| lst2(lst)                          | 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素 |
| lst2 = lst                         |                                                              |
| lst.size()                         | 列表中的元素数量                                             |
| lst.begin()                        | 返回指向lst中首元素的指针                                    |
| lst.end()                          | 返回指向lst中尾元素下一位置的指针                            |

和 vector 一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型。

initializer_list<string> ls;

和 vector 不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。

如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内：

error_msg({ "functionX", expected, actual}) ;

#### 省略符形参

省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为 varargs 的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用varargs。

省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。

## 返回值

#### 不要返回局部对象的引用或指针

#### 引用返回左值

调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用。（可赋值）

### 返回数组指针

因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名。

typedef int arrT[10];	// arrT是一个类型别名，它表示的类型是含有10个整数的数组
using arrT = int[10]； // arrT 的等价声明
arrT* func(int i);	// func返回一个指向含有10个整数的数组的指针

#### 声明一个返回数组指针的函数

要想在声明func时不使用类型别名，我们必须牢记被定义的名字后面数组的维度：

int arr[10];	// arr是一个含有10个整数的数组
int \*p1[10];	// p1是一个含有10个指针的数组
int (\*p2)[10]= &arr;	// p2是一个指针，它指向含有10个整数的数组

和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：

Type (\*function (parameter list)) [dimension ]

int (\*func(int i))[10];

可以按照以下的顺序来逐层理解该声明的含义：

- func(int i) 表示调用func函数时需要一个int类型的实参。
- (\*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作。
- (\*func(int i))[10] 表示解引用 func的调用将得到一个大小是10的数组。
- int (*func(int i)) [10] 表示数组中的元素是int类型。