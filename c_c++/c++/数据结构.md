# 数据类型

数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。

## 基本的内置类型

C++ 定义了，基本数据类型包括：**算术类型**（arithmetic type） 和 空类型（void）。算术类型包含了字符、整形数、布尔值和浮点数。**空类型**不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。

算术类型分为两类：整型（integral type，包括字符和布尔类型在内）和浮点型。

|    类型     |      含义      |   最小尺寸   |
| :---------: | :------------: | :----------: |
|    bool     |    布尔类型    |    未定义    |
|    char     |      字符      |     8位      |
|   wchar_t   |     宽字符     |     16位     |
|  char16_t   |  Unicode字符   |     16位     |
|  char32_t   |  Unicode字符   |     32位     |
|    short    |     短整型     |     16位     |
|     int     |      整型      |     16位     |
|    long     |     长整型     |     32位     |
|  long long  |     长整型     |     64位     |
|    float    |  单精度浮点数  | 6位有效数字  |
|   double    |  双精度浮点数  | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

**布尔类型**（bool）的取值是真（true）或者假（false）。

**基本的字符类型是 char**，一个 char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char 的大小和一个机器字节一样。

其他字符类型用于扩展字符集，如 wchar_t、char16_t、char32_t、wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型 char16_t 和 char32_t 则为 Unicode 字符集服务（Unicode 是用于表示所有自然语言中字符的标准）。

​	除字符和布尔类型之外，其他整型用于表示（可能）不同尺寸的整数。**C++语言规定一个int至少和一个short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和 一个 long 一样大**。其中，数据类型  long long 是在 C++11 中新定义的。

**浮点型**可表示单精度、双精度和扩展精度值。**C++标准指定了一个浮点数有效位数的最小值**，然而大多数编译器都实现了更高的精度。通常，float 以1个字(32比特)来表示，double 以2个字（64比特）来表示，long double 以3或4个字(96或128比特）来表示。一般来说，类型float和double分别有7和16个有效位；类型longdouble则常常被用于有特殊浮点需求的硬件，它的具体实现不同,精度也各不相同。

与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。

特别需要注意的是：**类型char和类型signed char并不一样**。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

### 类型转换

**特别注意含有无符号类型的表达式，不能出现负数**。切勿混用带符号和无符号类型。

如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为**带符号数会自动地转换成无符号数**。

### 字面值常量

每个字面值常量都对应一种数据类型，**字面值常量的形式和值决定了它的数据类型**。

整型字面值具体的数据类型由它的值和符号决定。

八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是int、long和1ong long中尺寸最小的那个（例如，三者当中最小是int），当然前提是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和 unsigned long long中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。

如果我们使用了一个形如-42的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

字符串字面值的类型实际上是由常量字符构成的数组（array），编译器在每个字符串的结尾处添加一个空字符（‘\0’）。

如果**两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体**。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式：

```c++
std::cout<<"a really,really long string literal"
    " that spans two lines"<<std::endl;
```

#### 转义字符

如果反斜线 \ 后面跟着的**八进制数字超过3个，只有前3个数字与 \ 构成转义序列**。例如，"\1234"表示2个字符，即八进制数123对应的字符以及字符4。相反，**\x 要用到后面跟着的所有数字**，例如，"\x1234" 表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。因为大多数机器的char型数据占8位，所以上面这个例子可能会报错。一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的扩展字符集一起使用的。

##### 指定字面值的类型

通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。
L'a'				//宽字符型字面值，类型是wchar_t
u8"hi!"		// utf-8字符串字面值（utf-8用8位编码一个Unicode字符）
42ULL		//无符号整型字面值，类型是unsigned long long
1E-3F			//单精度浮点型字面值，类型是float
3.14159L	//扩展精度浮点型字面值，类型是long double

| 前缀 |            含义             |   类型   |
| :--: | :-------------------------: | :------: |
|  u   |       Unicode 16字符        | char16_t |
|  U   |       Unicode 32字符        | char32_t |
|  L   |           宽字符            | wchar_t  |
|  u8  | UTF-8(仅用于字符串字面常量) |   char   |

|   后缀   | 最小匹配类型 |
| :------: | :----------: |
|  u or U  |   unsigned   |
|  l or L  |     long     |
| ll or LL |  long long   |
|  f or F  |    float     |
|  l or L  | long double  |

nullptr是指针字面值。

## 变量

#### 列表初始化

```c++
int units_sold = 0;
int units_sold ={0};
int units_sold{0};
int units_ sold(0);
```

作为**C++11新标准**的一部分，用花括号来初始化变量得到了全面应用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用。这种初始化的形式被称为**列表初始化**（list initialization）。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用**这样一组由花括号括起来的初始值**了。

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且**初始值存在丢失信息的风险**，则编译器将报错：

```c++
long double ld = 3.1415926536;
int a{ld},b= {ld};	//错误：转换未执行，因为存在丢失信息的危险
int c(ld),d= ld;		//正确：转换执行，且确实丢失了部分值
```

使用1ong double的值初始化int变量时可能丢失数据，所以编译器拒绝了a和b的初始化请求。其中，至少 ld的小数部分会丢失掉，而且int也可能存不下 ld的整数部分。

#### 默认初始值化

默认值到底是什么由变量类型决定，同时**定义变量的位置**也会对此有影响。
	如果是**内置类型**的变量未被显式初始化，它的值由定义的位置决定。定义于**任何函数体之外**的变量被初始化为0。一种例外情况是，定义在**函数体内部**的内置类型变量**将不被初始化**（uninitialized）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将**引发错误**。
**类的对象如果没有显式地初始化，则其值由类确定**。

#### 变量声明和定义

**声明**（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。

**定义**（definition）负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，**定义还申请存储空间，也可能会为变量赋一个初始值**。
​如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量。

extern语句如果包含初始值就不再是声明，而变成了定义。

```c++
extern double pi= 3.1416； //定义
```

在**函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误**。

**变量能且只能被定义一次，但是可以被多次声明。**

#### 静态类型

C++是一种静态类型（statically typed）语言，其含义是**在编译阶段检查类型**。其中，检查类型的过程称为类型检查（type checking）。

#### 标识符

C++的标识符（identifier）由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写字母敏感。

C++也为标准库保留了一些名字。用户自定义的**标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头**。此外，定义在函数体外的标识符不能以下画线开头。

##### C++操作符替代名

and	bitand	bitor	compl	not_eq	or	or_eg	xor_ eg	and_eq	not	xor

## 复合类型

引用和指针。

### 引用

- 左值引用
- 右值引用

引用（reference）为对象起了另外一个名字，**引用类型引用（refers to）另外一种类型**。通过将声明符写成 &d 的形式来定义引用类型，其中d是声明的变量名：

```c++
int ival = 1024;
int &refVal = ival;		// refVal指向ival（是ival的另一个名字）
int &refVal2;				//报错：引用必须被初始化
```

定义引用时，**程序把引用和它的初始值绑定（bind）在一起**，而不是将初始值拷贝给引用。**一旦初始化完成，引用将和它的初始值对象一直绑定在一起**。因为无法令引用重新绑定到另外一个对象，因此**引用必须初始化**。

因为**引用本身不是一个对象**，所以不能定义引用的引用。

所有引用的**类型**都要和与之绑定的对象**严格匹配**。而且，引用**只能绑定在对象**上，而不能与字面值或某个表达式的计算结果绑定在一起。

一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

### 指针

指针（pointer）是“指向（point to）”另外一种类型的复合类型。指针与引用相比又有很多不同点。

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

在声明语句中指针的**类型**实际上被用于指定它所指向对象的类型，所以二者必须**匹配**。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

#### 空指针

空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：

```c++
int *pl= nullptr;			//等价于int *p1= 0；
int *p2=0;					//直接将p2初始化为字面常量0
//需要首先#include cstdlib
int *p3= NULL;			//等价于int *p3=0；
```

得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。**nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型**。另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。
过去的程序还会用到一个名为NULL的预处理变量（preprocessor variable）来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。

##### 预处理

当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用NULL初始化指针和用0初始化指针是一样的。在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。
把int变量直接赋给指针是错误的操作，即使int变量的值怡好等于0也不行。

```c++
int zero =0;
pi= zero;			//错误：不能把int变量直接赋给指针
```

#### void* 指针

void\* 是一种特殊的指针类型，可**用于存放任意对象的地址**。一个void\*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

概括说来，以 void\* 的视角来看内存空间也就**仅仅是内存空间**，没办法访问内存空间中所存的对象。

#### 复合类型的声明

基本数据类型是int而非int\*。仅仅是修饰了p而已，对该声明语句中的其他变量，它并不产生任何作用：

```c++
int* p1,p2;//p1是指向int的指针，p2是int
```

##### 指向指针的指针

通过*的个数可以区分指针的级别。也就是说，\*\* 表示指向指针的指针，\***表示指向指针的指针的指针，以此类推。

##### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```c++
int i=42;
int *p;	 //p是一个int型指针
int*&r= p;	//r是一个对指针p的引用
r=&i;	//r引用了一个指针，因此给r赋值&i就是令p指向i
*r=0;	//解引用r得到i，也就是p指向的对象，将i的值改为0
```

要理解r的类型到底是什么，最简单的办法是**从右向左阅读**r的定义。离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定 r 引用的类型是什么，此例中的符号 \*说明 r 引用的是一个指针。最后，声明的基本数据类型部分指出 r 引用的是一个int指针。

**面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。**

## const 限定符

**const对象一旦创建后其值就不能再改变**，所以const对象必须初始化。

```c++
const int i = get_size();	//正确：运行时初始化
const int j = 42;		//正确：编译时初始化
```

**默认情况下，const 对象仅在文件内有效**。
编译器将**在编译过程中把用到该变量的地方都替换成对应的值**。
**const 变量多文件共享**，解决的办法是，对于 const变量不管是声明还是定义都添加 extern关键字，这样只需定义一次就可以了。

#### const的引用

把引用绑定到const对象上，称之为**对常量的引用**（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci=1024;
const int &rl = ci；//正确：引用及其对应的对象都是常量
rl=42;	//错误：r1是对常量的引用
int &r2=ci;	//错误：试图让一个非常量引用指向一个常量对象
```

因为不允许直接为 ci 赋值，当然也就不能通过引用去改变 ci。因此，对 r2 的初始化是错误的。

**初始化和对 const 的引用**

​	引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：

```c++
int i= 42;.
const int &r1=i;			//允许将const int&绑定到一个普通int对象上
const int &r2= 42;		//正确：r1是一个常量引用
const int &r3 =r1 *2；//正确：r3是一个常量引用
int &r4=r1*2;					//错误：r4是一个普通的非常量引用
```

要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：

```c++
double dval =3.14;
const int &ri= dval;
```

此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式：

```c++
const int temp = dval;		//由双精度浮点数生成一个临时的整型常量
const int &ri = temp;		//让 ri 绑定这个临时量
```

在这种情况下，ri绑定了一个**临时量**（temporary）对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。
接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则干什么要给ri赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为**非法**。

##### 对 const 的引用可能引用一个并非 const 的对象

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i= 42;
int &rl =i; //引用ri绑定对象i
const int &r2=i; //r2也绑定对象i，但是不允许通过r2修改主的值
rl =0; // r1并非常量，i的值修改为0
r2=0; //错误：r2是一个常量引用
```


r2绑定（非常量）整数 i 是合法的行为。然而，不允许通过 r2 修改 i 的值。尽管如此，i 的值仍然允许通过其他途径修改，既可以直接给 i 赋值，也可以通过像 r1 一样绑定到i的其他引用来修改。

### 指针和 const

要想存放常量对象的地址，只能使用指向常量的指针。

```c++
const double pi = 3.14;	//pi是个常量，它的值不能改变
const double *cptr = &pi;	//cptr可以指向一个常量
```

2.3.2节（第47页）提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：

```c++
double dval =3.14; // dval是一个双精度浮点数，它的值可以改变
cptr = &dval; //正确：但是不能通过cptr改变dval的值
```

指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

#### const 指针

**常量指针**（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个**地址**）就不能再改变了。

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：

```c++
int errNumb = 0;
int *const curErr= &errNumb; //常量指针
const double pi=3.14159;
const double *const pip = &pi; // pip是一个指向常量对象的常量指针
```

#### 顶层const

顶层 const（top-level const）表示**指针本身是个常量**，而用名词底层const （low-level const）表示指**针所指的对象是一个常量**。

### constexpr 和常量表达式

##### 常量表达式

常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

```c++
const int max_files = 20; // max_files是常量表达式
const int sz = get_size(); //sz 不是常量表达式
```

##### constexpr 变量

**C++11**新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：

```c++
constexpr int mf = 20; // 20是常量表达式
constexpr int limit =mf +1;	//mf +1是常量表达式
constexpr int sZ= size(); //只有当size是一个constexpr函数时//才是一条正确的声明语句
```

新标准允许定义一种特殊的**constexpr函数**。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。

##### 指针和 constexpr

必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：

```c++
const int *p= nullptr; //p是一个指向整型常量的指针
constexpr int *q= nullptr; //q是一个指向整数的常量指针
```

p和q的类型相差甚远，**p是一个指向常量的指针，而q是一个常量指针**，其中的关键在于**constexpr把它所定义的对象置为了*顶层const***。

```c++
constexpr const int *p = &i;	//p是常量指针，指向整型常量i
```

## 处理类型

### 类型别名

类型别名（type alias）是一个名字，它是某种类型的同义词。
有两种方法可用于定义类型别名。传统的方法是使用关键字**typedef**：

```c++
typedef double wages; //wages是double的同义词
typedef wages base，*p; //base是double的同义词，p是double*的同义词
```

新标准规定了一种新的方法，使用**别名声明**（alias declaration）来定义类型的别名：

```c++
using SI = Sales_item; // SI是Sales item的同义词
```

这种方法用**关键字using作为别名声明的开始**，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

#### 指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char*的别名：

```c++
typedef char *pstring;
const pstring cstr = 0; // cstr是指向char的常量指针
const pstring *ps; // ps是一个指针，它的对象是指向char的常量指针
```

上述两条声明语句的基本数据类型都是 const pstring，和过去一样，**const是对给定类型的修饰**。pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。
遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：

```c++
const char *cstr = 0;	//是对const pstring cstr的错误理解
```

再强调一遍：这种理解是错误的。声明语句中用到 pstring 时，**其基本数据类型是指针**。可是用char\* 重写了声明语句后，数据类型就变成了char，*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

### auto类型说明

C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。**auto 让编译器通过初始值来推算变量的类型**。显然，auto定义的变量必须有初始值：

```c++
//由vall和val2相加的结果可以推断出item的类型
auto item = vall + val2；// item初始化为vall和val2相加的结果
```

**使用auto也能在一条语句中声明多个变量**。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：

```c++
auto i=0,*p= &i;//正确：i是整数、p是整型指针
auto sz =0，pi= 3.14；//错误：sz和pi的类型不一致
```

#### 复合类型、常量和 auto

编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。
首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：

```c++
int i=0, &r=i;
auto a=r;		//a是一个整数（r是主的别名，而i是一个整数）
```

其次，**auto一般会忽略掉顶层const，同时底层const则会保留下来**，比如当初始值是一个指向常量的指针时：

```c++
const int ci=i, &cr = ci;
auto b= ci；	//b是一个整数（ci的顶层const特性被忽略掉了）
auto c = cr； 	//c是一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i； 	//d是一个整型指针（整数的地址就是指向整数的指针）
auto e= &ci； 	//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）
```

如果**希望推断出的auto类型是一个顶层const**，需要明确指出：

```c++
const auto f = ci; // ci的推演类型是int，f是const int
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：

```c++
auto &g = ci;		//g是一个整型常量引用，绑定到ci
auto &h=42;		//错误：不能为非常量引用绑定字面值
const auto &j=42;	//正确：可以为常量引用绑定宇面值
```

设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。
	要在一条语句中定义多个变量，切记，符号&和\*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型:

```c++
auto k= ci, &l =i;			//k是整数，1是整型引用
auto &m = ci，*p= &ci；	//m是对整型常量的引用，p是指向整型常量的指针
//错误：i的类型是int而&ci的类型是const int
auto &n = i,*p2 -= &ci;
```

### decltytype 类型

有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，**C++11** 新标准引入了第二种类型谠说明符 decltype，它的作用是**选择并返回操作数的数据类型**。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：

```c++
decltype(f()) sum = x；// sum的类型就是函数£的返回类型
```

**编译器并不实际调用函数 f**，而是使用当调用发生时£的返回值类型作为sum的类型。
decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个**变量**，则decltype返回该变量的类型（**包括顶层const和引用在内**）：

```c++
const int ci=0,&cj= ci;
decltype(ci) x=0;		//x的类型是const int
decltype(cj) y= x;		//y的类型是const int&，y绑定到变量x
decltype(cj) z;			//错误：z是一个引用，必须初始化
```

需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在 decltype 处是一个例外。

#### decltype 和引用

如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：

```c++
// decltype的结果可以是引用类型
int i- 42,*p= &i, &r = i;
decltype(r +0) b；	//正确：加法的结果是int，因此b是一个（未初始化的）int
decltype(*p) c;		  //错误：c是int&，必须初始化
```

​	因为r是一个引用，因此decltype （r）的结果是引用类型。如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，如 r+0，显然这个表达式的结果将是一个具体值而非一个引用。
​	另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype（*p）的结果类型就是int&，而非int。
​	decltype 和 auto 的另一处重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于 decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果 decltype 使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype 就会得到引用类型：

```c++
// decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d;		//错误：d是int&，必须初始化
decltype(i) e;		  //正确：e是一个（未初始化的）int
```

**切记：decltype((variable)) （注意是双层括号）的结果永远是引用，而 decltype(variable) 结果只有当 variable 本身就是一个引用时才是引用**。

### 自定义数据结构

struct  和 class 的使用。struct 只含数据元素结构，不包含方法。

类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少。

```c++
struct Sales_data { /*...*/} accum,trans,*salesptr;
```

### 预处理器

#### 预处理功能

- 头文件 #include
- 头文件保护符 #ifdef   #ifndef

确保头文件多次包含仍能安全工作的常用技术是**预处理器**（preprocessor）。当预处理器看到#include标记时就会用指定的头文件的内容代替#include。
C++程序还会用到的一项预处理功能是**头文件保护符**（header guard），头文件保护符依赖于预处理变量。预处理变量有两种状态：**已定义和未定义**。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
**使用这些功能就能有效地防止重复包含的发生**：

```c++
#ifndef SALES DATA H
#define SALES DATAH
#include <string>

struct Sales_data {
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue =0.0;
};
#endif
```

**预处理变量无视 c++ 语言中关于作用域的规则**。



## 附

#### 字

字(word）在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节。