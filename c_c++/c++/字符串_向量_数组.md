# 字符串、向量和数组

C++ 的抽象数据类型，string和vector是两种最重要的标准库类型，前者支持可变长字符串，后者则表示可变长的集合。还有一种标准库类型是迭代器，它是string 和 vector的配套类型，常被用于访问string中的字符或vector中的元素。内置数组是一种更基础的类型，string和 vector都是对它的某种抽象。

### 命名空间的 using 声明

**作用域操作符(::)** 的含义是：编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。

通过更简单的途径也能使用到命名空间中的成员。使用using声明。
有了using声明就无须专门的前缀（形如命名空间:;）也能使用所需的名字了。

```c++
using namespace::name;
```

一旦声明了上述语句，就可以直接访问命名空间中的名字：

```c++
#include <iostream>
// using声明，当我们使用名字cin时，从命名空间std中获取它
using std::cin;
```

按照规定，每个名字都需要独立的 using 声明，每个 using 声明引入命名空间中的一个成员。

#### 头文件不应包含 using 声明

这是因为头文件的内容会拷贝到所有引用它的文件中去。

## 标准库类型 string

标准库类型 string表示**可变长的字符序列**，使用 string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。

```c++
#include <string>
using std::string;
```

### 初始化 string 

```c++
string sl;				//默认初始化，s1是一个空串
string s2 (s1);			//s2是s1的副本
string s2 = sl;			//等价于s2(s1)，s2是s1的副本
string s3 ("value"); 	//s3是字面值"value"的副本，除了字面值最后的那个空字符外
string s3 = "value";	//等价于s3（"value"），s3是字面值"value"的副本
string s4(n, 'c');		//把s4的内容为 cccccccccc
```

#### 直接初始化和拷贝初始化

如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化**（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是**直接初始化**(direct initialization)。

### string 的操作

> os<<s				将s写到输出流os当中，返回os
> is>>s		 		 从is中读取字符串赋给s，字符串以空白分隔，返回is
> getline(is,s)	  从is中读取一行赋给s，返回is
> s.empty()	  	s为空返回true，否则返回false
> s.size()			  返回s中字符的个数
> s[n]				   返回s中第n个字符的引用，位置n从0计起
> s1+s2			   返回s1和s2连接后的结果
> sl=s2				 用s2的副本代替s1中原来的字符
> sl==s2			   如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感
> s1!=s2				等性判断对字母的大小写敏感
> <,<=,>,>=		   利用字符在字典中的顺序进行比较，且对字母的大小写敏感

#### 读写 string对象

触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符。

```c++
int main()
{
    string line;
    //每次读入一整行，直至到达文件末尾
    while(getline(cin,line))
    	cout<< line<<endl;
    return 0;
}
```

因为line中不包含换行符，所以我们手动地加上换行操作符。和往常一样，使用endl结束当前行并刷新显示缓冲区。

### string::size_type 类型

过去，string : :size type这种类型有点儿神秘，不太容易理解和使用。在C++11新标准中，允许编译器通过 auto 或者 decltype 来推断变量的类型:

```c++
auto len = line.size(); ll len 的类型是string : :size_type
```


由于 **size 函数返回的是一个无符号整型数**，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。

### string 相加

#### 字面值和 string 相加

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string：

```c++
string s4 =s1 +",";		//正确：把一个string对象和一个字面值相加
string s5 = "hello" +"，"；	//错误：两个运算对象都不是string
//正确：每个加法运算符都有一个运算对象是string
string s6=sl +","+ "world";
string s7 = "hello"+"，"+ s2；	 //错误：不能把字面值直接相加
```

s6的初始化形式之前没有出现过，但其实它的工作机理和连续输入连续输出是一样的，可以用如下的形式分组：

```c++
string s6 = (s1 +",") +"world";
```

其中子表达式s1 +"，"的结果是一个string对象，它同时作为第二个加法运算符的左侧运算对象，因此上述语句和下面的两个语句是等价的：

```c++
string tmp=s1 +"，"；	//正确：加法运算符有一个运算对象是string
s6= tmp + "world";		 //正确：加法运算符有一个运算对象是string
```

因为某些历史原因，也为了与C兼容，所以 C++语言中的字符串字面值并不是标准库类型string的对象。切记，**字符串宇面值与string是不同的类型**。

在 **cctype头文件**中定义了一组标准库函数处理这部分工作，下表列出了主要的函数名及其含义。cctype 头文件中的函数：

|    函数     | 函数说明                                                     |
| :---------: | ------------------------------------------------------------ |
| isalnum(c)  | 当c是字母或数字时为真                                        |
| isalpha (c) | 当c是字母时为真                                              |
| iscntrl(c)  | 当c是控制字符时为真                                          |
| isdigit(c)  | 当c是数字时为真                                              |
| isgraph (c) | 当c不是空格但可打印时为真                                    |
| islower(c)  | 当c是小写字母时为真                                          |
| isprint(c)  | 当c是可打印字符时为真（即c是空格或c具有可视形式）            |
| ispunct(c)  | 当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种） |
| isspace(c)  | 当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） |
| isupper(c)  | 当c是大写字母时为真                                          |
| isxdigit(c) | 当c是十六进制数字时为真                                      |
| tolower(c)  | 如果c是大写字母，输出对应的小写字母；否则原样输出c           |
| toupper(c)  | 如果c是小写字母，输出对应的大写字母；否则原样输出c           |

**注意：**

一般来说，C++程序应该使用名为**cname 的头文件**而不使用name.h的形式，标准库中的名字总能在命名空间 std 中找到。如果使用 .h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。

#### 范围 for

范围for （range for）语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：

```c++
for (declaration : expression)
	statement
```

**如果想要改变string对象中字符的值，必须把循环变量定义成引用类型**。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。

```c++
string s("Hello World!!!");
//转换成大写形式。
for (auto &c : s)
	//对于s中的每个字符（注意：c是引用）
	c = toupper (c);
	//c是一个引用，因此赋值语句将改变s中字符的值
cout << s << endl;
```

如果某个索引是带符号类型的值将自动转换成由 string::size_type 表达的无符号类型。

```c++
decltype(s.size()) index = 0;	//这类型定义可确保不会小于0
```

## vector

标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector “容纳着” 其他对象，所以它也常被称作容器(container)。

```c++
#include <vector>
using std::vector;
```

C++语言既有类模板 （class template），也有函数模板，其中vector是一个类模板。

对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息。
以vector为例，提供的额外信息是vector内所存放对象的类型：

```c++
vector<int> ivec;	// ivec保存int类型的对象
vector<Sales_item> Sales_vec;	//保存Sales_item类型的对象
vector<vector<string>> file;	//该向量的元素是vector对象
```

在上面的例子中，编译器根据模板 vector 生成了三种不同的类型： vector<int\>、vector<Sales item\>和vector<vector<string\>>。

vector 是模版而非类型，由 vector 生成的类型必须包含 vector 中元素的类型，例如 vector<int\>。

vector能容纳绝大多数类型的对象作为其元素，但是因为**引用不是对象，所以不存在包含引用的vector**。除此之外，其他大多数（非引用）内置类型和类类型都可以构成 vector对象，甚至组成vector的元素也可以是vector。

某些编译器可能仍需以**老式**的声明语句来处理元素为 vector的 vector对象，如

**vector<vector\<int\> \>**

#### 定义和初始化 vector 对象

|           函数           | 函数说明                                                |
| :----------------------: | ------------------------------------------------------- |
|      vector<T\> v1       | v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 |
|    vector<T\> v2(v1)     | v2中包含有v1所有元素的副本                              |
|     vector<T\> v2=v1     | 等价于v2（v1），v2中包含有v1所有元素的副本              |
|  vector<T\> v3(n, val)   | v3包含了n个重复的元素，每个元素的值都是val              |
|     vector<T\> v4(n)     | v4包含了n个重复地执行了值初始化的对象                   |
| vector<T\> v5{a,b,c...}  | v5包含了初始值个数的元素，每个元素被赋予相应的初始值    |
| vector<T\> v5={a,b,c...} | 等价于v5{a，b，c...}                                    |

#### 列表初始化

```c++
vector<string> articles = {"a", "an", "the"};
```

如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里：

```c++
vector<string> v1{"a","an","the"};	//列表初始化
vector<string> v2("a","an""the");	//错误
```

另一方面，如果**初始化时使用了花括号的形式但是提供的值又不能用来列表初始化**，就要考虑用这样的值来构造 vector 对象了。例如，要想列表初始化一个含有 string 对象的 vector 对象，应该提供能赋给 string 对象的初值。此时不难区分到底是要列表初始化 vector对象的元素还是用给定的容量值来构造 vector对象：

```c++
vector<string> v5{"hi"}；	//列表初始化：v5有一个元素
vector<string> v6("hi"); 	//错误：不能使用字符串字面值构建vector对象
vector<string> v7{10};		//v7有10个默认初始化的元素
vector<string> v8{10, "hi"};	//v8有10个值为"hi"的元素
```

尽管在上面的例子中除了第二条语句之外都用了花括号，但其实只有v5是列表初始化。要想列表初始化 vector 对象，花括号里的值必须与元素类型相同。显然不能用int 初始化 string 对象，所以 v7 和 v8 提供的值不能作为元素的初始值。确认无法执行列表初始化后，编译器会尝试用默认值初始化 vector对象。

### 添加元素

push_back向其中添加元素。push_back负责把一个值当成vector对象的尾元素“压到（push）”vector对象的“尾端（back）”。例如：

```c++
vector<int> v2;	//空vector对象
for (int i = 0; i != 100; ++i)
	v2.push_back（i）；//依次把整数值放到v2尾端
```

**注意：**

如果循环体内部包含有向 vector 对象添加元素的语句，则不能使用范围 for循环。范围 for 语句体内不应改变其所遍历序列的大小。(因为 vector 对象能高效增长)

#### 其他 vector 操作

|       函数       | 函数说明                                                     |
| :--------------: | ------------------------------------------------------------ |
|    v.empty()     | 如果v不含有任何元素，返回真；否则返回假                      |
|     v.size()     | 返回v中元素的个数                                            |
|  v.push_back(t)  | 向v的尾端添加一个值为七的元素                                |
|       v[n]       | 返回v中第n个位置上元素的引用                                 |
|      v1=v2       | 用v2中元素的拷贝替换v1中的元素                               |
| v1= {a，b，c...} | 用列表中元素的拷贝替换v1中的元素                             |
|      vl==v2      | v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
|      v1!=v2      |                                                              |
|    <，<=,>,>=    | 顾名思义，以字典顺序进行比较                                 |

要使用 size_ type，需首先指定它是由哪种类型定义的。vector 对象的类型总是包含着元素的类型：

```c++
vector<int>::size_type		//正确
vector::size type			//错误
```

##### 不能用下标形式添加元素

下面的代码试图为vector对象ivec添加10个元素：

```c++
vector<int> ivec; //空 vector对象
for (decltype (ivec.size())ix =0;ix != 10;++ix)
	ivec[ix] = ix； //严重错误：ivec不包含任何元素
```

然而，这段代码是错误的：ivec是一个空 vector，根本不包含任何元素，当然也就不能通过下标去访问任何元素！如前所述，正确的方法是使用push_back：

```c++
for (decltype(vec.size())ix = 0;ix!= 10; ++ix)
	ivec.push_ back(ix);//正确：添加一个新元素，该元素的值是ix
```

vector 对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。

### 迭代器

迭代器有有效和无效之分，有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

#### 使用迭代器

迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin 和 end的成员，其中begin 成员负责返回指向第一个元素（或第一个字符）的迭代器。

```c++
//由编译器决定b和e的类型
//b 表示 v 的第一个元素，e 表示 v 尾元素的下一位置
auto b=v.begin（），e=v.end（）；// b 和 e 的类型相同
```

end成员则负责返回指向容器（或string对象）“**尾元素的下一位置（one past the end）**”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“尾后（off the end）”元素。end成员返回的迭代器常被称作**尾后迭代器**（off-the-end iterator）或者简称为尾迭代器（end iterator）。特殊情况下如果容器为空，则begin 和 end返回的是同一个迭代器。

**如果容器为空，则begin 和end返回的是同一个迭代器，都是尾后迭代器。**

#### 迭代器运算符

|    运算符     | 运算符说明3                                                  |
| :-----------: | ------------------------------------------------------------ |
|     *iter     | 返回迭代器iter所指元素的引用                                 |
|   iter->mem   | 解引用iter并获取该元素的名为mem的成员，等价于（*iter）.mem   |
|    ++iter     | 令iter指示容器中的下一个元素                                 |
|    --iter     | 令iter指示容器中的上一个元素                                 |
| iterl==iter2  | 判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等； |
| iterl!= iter2 | 反之，不相等                                                 |

**注意**：

原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使 **用 != 而非 <** 进行判断有点儿奇怪。C++程序员习惯性地使用 != ，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。
之前已经说过，只有string 和 vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了 == 和 != ，但是它们中的大多数都没有定义 < 运算符。因此，只要我们养成使用迭代器和 != 的习惯，就不用太在意用的到底是哪种容器类型。

**迭代器类型**

就像不知道 string和 vector的size_type成员到底是什么类型一样，一般来说我们也不知道（其实是无须知道）迭代器的精确类型。而实际上，那些拥有迭代器的标准库类型使用iterator 和const_iterator来表示迭代器的类型：

```c++
vector<int>::iterator it;	//it能读写vector<int>的元素
string::iterator it2;	//it2能读写string对象中的字符
vector<int>::const_iterator it3;	// it3只能读元素，不能写元素
string::const_iterator it4;	// it4只能读字符，不能写字符
```


const_iterator 和常量指针（参见2.4.2节，第56页）差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果 vector对象或string对象是一个常量，只能使用const iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const iterator。

**begin 和 end 运算符**

begin 和 end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator。

```c++
vector<int> v;
const vector<int> cv;
auto itl = v.begin();	//itl的类型是vector<int>::iterator
auto it2 = cv.begin();	//it2的类型是vector<int>::const_iterator
```

有时候这种默认的行为并非我们所要。如果对象只需读操作而无须写操作的话最好使用常量类型（比如const _iterator）。为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是**cbegin**和 **cend**：

类似于 begin 和 end，上述两个新函数也分别返回指示容器第一个元素或最后元素下一位置的迭代器。有所不同的是，不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

```c++
auto it3 = v.cbegin（）；// it3的类型是vector《int》：：const_iterator
```

类似于 begin 和 end，上述两个新函数也分别返回指示容器第一个元素或最后元素下一位置的迭代器。有所不同的是，不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

**结合解引用和成员访问操作**

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。例如，对于一个由字符串组成的vector对象来说，要想检查其元素是否为空，令it是该vector对象的迭代器，只需检查it所指字符串是否为空就可以了，其代码如下所示：

```c++
(*it).empty()
```

注意，(\*it).empty() 中的圆括号必不可少，该表达式的含义是先对 it 解引用，然后解引用的结果再执行点运算符。如果不加圆括号，点运算符将由 it 来执行，而非it解引用的结果：

```c++
(*it).empty()
//解引用it，然后调用结果对象的empty成员
*it.empty()
//错误：试图访问it的名为empty的成员，但it是个迭代器，//没有empty成员
```

上面第二个表达式的含义是从名为it的对象中寻找其 empty成员，显然it是一个迭代器，它没有哪个成员是叫empty的，所以第二个表达式将发生错误。
为了简化上述表达式，C++语言定义了箭头运算符(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it->mem和 (*it).mem 表达的意思相同。

```c++
//依次输出text的每一行直至遇到第一个空白行为止
for (auto it = text.cbegin() ;it != text.cend() && !it->empty(); ++it)
    cout << *it << endl;
```

**某些对vector对象的操作会使迭代器失效**

虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如 push_back，都会使该vector对象的迭代器失效。将详细解释迭代器是如何失效的。

**但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素**。

**迭代器运算**

| 运算符        | 运算符说明                                                   |
| ------------- | ------------------------------------------------------------ |
| iter +n       | 迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置 |
| iter -n       | 迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置 |
| iterl+=n      | 迭代器加法的复合赋值语句，将iter1加n的结果赋给iterl          |
| iterl -=n     | 迭代器减法的复合赋值语句，将iterl减n的结果赋给iter1          |
| iterl - iter2 | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭<br/>代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置 |
| \>、>=、<、<= | 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置 |

对于 string 或 vector 的迭代器来说，除了判断是否相等，还能使用关系运算符（<、<=、>、>=）对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。

所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和vector都定义了difference_type，因为这个距离可正可负，所以difference_type是带符号类型的。

#### 数组

数组是一种类似于标准库类型 vector 的数据结构，但是在性能和灵活性的权衡上又与 vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。

##### 定义和初始化内置数组

数组是一种复合类型。数组的声明形如a[d]，其中a是数组的名字，d是数组的维度。维度说明了数组中元素的个数，因此必须大于0。数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式：

```c++
unsigned cnt = 42;	//不是常量表达式
constexpr unsigned sz= 42;	//常量表达式
int arr[10];	//含有10个整数的数组
int *parr[sz];	//含有42个整型指针的数组
string bad[cnt];	//错误：cnt不是常量表达式
string strs[get_size()]; //当get_size是constexpr时正确；否则错误
```

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和 vector 一样，数组的元素应为对象，因此不存在引用的数组。

**字符数组的特殊性**

字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：

```c++
char al[] ={'C','+','+'};	//列表初始化，没有空字符
char a2[] ={'C','+','+','0'};	//列表初始化，含有显式的空字符
char a3[]="C++";	//自动添加表示字符串结束的空字符
const char a4[6]="Daniel";	//错误：没有空间可存放空字符！
```

**不允许拷贝和赋值**

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```c++
int a[] ={0,1,2};	//含有3个整数的数组
int a2[]=a;	//错误：不允许使用一个数组初始化另一个数组
a2= a;	//错误：不能把一个数组直接赋值给另一个数组
```

**一些编译器支持数组的赋值，这就是所谓的编译器扩展（compiler extension）。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。**

**理解复杂的数组声明**

```c++
int *ptrs[10]; // ptrs是含有10个整型指针的数组
int &refs[10]=/*?*/; //错误：不存在引用的数组
int (*Parray)[10]= &arr; // Parray指向一个含有10个整数的数组
int (&arrRef)[10]= arr;	// arrRef 引用一个含有10个整数的数组
```

默认情况下，类型修饰符从右向左依次绑定。对于ptrs来说，从右向左理解其含义比较简单：首先知道我们定义的是一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。
但是对于Parray来说，从右向左理解就不太合理了。因为数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解Parray的含义：首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道 Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是个指针，它指向一个int数组，数组中包含10个元素。同理，（&arrRef）表示arrRef是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是int。
当然，对修饰符的数量并没有特殊限制：

```c++
int *（&arry）【10】 = ptrs； // arry是数组的引用，该数组含有10个指针
```

按照由内向外的顺序阅读上述语句，首先知道arry是一个引用，然后观察右边知道，arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用。

**要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。**