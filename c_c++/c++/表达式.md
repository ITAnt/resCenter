# 表达式

C++语言提供了一套丰富的运算符，并定义了这些运算符作用于**内置类型**的运算对象时所执行的操作。同时，当运算对象是**类类型**时，C++语言也允许由用户指定上述运算符的含义。

### 左值与右值

使用关键字decltype 的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。举个例子，假定p的类型是int\*，因为解引用运算符生成左值，所以decltype（\*p）的结果是int&。另一方面，因为取地址运算符生成右值，所以decltype（&p）的结果是int\*\*，也就是说，结果是一个指向整型指针的指针。

### 混用解引用和递增运算符

```c++
auto pbeg = v.begin();
//输出元素直至遇到第一个负值为止
while (pbeg != v.end()&&*beg >=0)
cout << *pbeg++ << endl； //输出当前值并将pbeg向前移动一个元素
```

*pbeg++ 这种写法很普遍。

后置递增运算符的优先级高于解引用运算符，因此\*pbeg++等价于\*(pbeg++)。

### 成员访问运算符

点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式 ptr->mem 等价于 (\*ptr).mem，-> 为解引用+成员变量访问。

因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。

### 位运算符

一种名为 bitset 的标准类型也可以表示任意大小的二进制位集合，所以位运算符同样用于 bitset 类型。

### sizeof 运算符

 sizeof运算符返回一条表达式或一个类型名字所占的字节数。 sizeof运算符满足**右结合律**，其所得的值是一个**size类型**的**常量表达式**。

> sizeof (type)	//类型
>
> sizeof expr	//返回表达式结果类型的大小

sizeof 并不实际计算其运算对象的值。

sizeof \*p。因为 sizeof满足右结合律并且与运算符的优先级一样，所以表达式按照从右向左的顺序组合。也就是说，它等价于 sizeof(\*p)。其次，因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。在 sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。 sizeof不需要真的解引用指针也能知道它所指对象的类型。

sizeof运算符的结果部分地依赖于其作用的类型：

- 对char或者类型为char的表达式执行sizeof运算，结果得1。
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。
- 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。
- 对 string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

```c++
// sizeof(ia)/sizeof(*ia) 返回 ia 的元素数量
constexpr size_t sz = sizeof(ia)/sizeof (*ia);
int arr2 [sz];	//正确：sizeof返回一个常量表达式
```

因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。

### 逗号运算符

逗号运算符（comma operator）含有两个运算对象，按照从左向右的顺序依次求值。

对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值,那么最终的求值结果也是左值。

### 隐式转换

##### 数组转换成指针

在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。

当数组被用作 decltype 关键字的参数，或者作为取地址符（&）、sizeof 及 typeid 等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组，上述转换也不会发生。当在表达式中使用函数类型时会发生类似的指针转换。

##### 指针的转换

C++还规定了几种其他的指针转换方式，包括常量整数值0或者字面值nullptr能转换成任意指针类型：指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void*。在有继承关系的类型间还有另外一种指针转换的方式。

### 命名的强制类型转换

- static_cast
- dynamic_cast
- const_cast
- reinterpret_cast

#### static_cast

任何具有明确定义的类型转换，只要不包含底层const，都可以使用 static_cast。

``` c++
//进行强制类型转换以便执行浮点数除法
double slop = static_cast<double>(j)/i;
//使用 static_cast 找回存在于 void* 指针中的值
void* p = &d;
//将 void* 转换会初始的指针类型
double *dp = static_cast<double*>(p);
```

当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。

#### const_cast

const_cast只能改变运算对象的底层const。

```c++
const char *pc;
char *p = const_cast<char*>(pc)； //正确：但是通过p写值是未定义的行为
```

对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉 const性质（cast awaythe const）”。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast 执行写操作就会产生**未定义**的后果。
只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能用const_cast改变表达式的类型：

```c++
const char *cp;
//错误：static_cast不能转换掉const性质
char *q = static_cast<char*>(cp);
static_cast<string>(cp);
//正确：字符串字面值转换成string类型
const_cast<string>(cp);
//错误：const_cast只改变常量属性
```

#### reinterpret_cast

reinterpret_cast通常为运算对象的**位模式**提供较低层次上的重新解释。

```c++
int *ip;
char *pc= reinterpret_cast<char*>(ip);
```

我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。例如：

```c++
string str(pc);
```


可能导致异常的运行时行为。

使用reinterpret cast是非常危险的，仅从语法上而言这种操作无可指摘。但不建议使用。

#### 旧式的强制类型转换

在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：

> type (expr);
> //函数形式的强制类型转换
> (type) expr;
> //C语言风格的强制类型转换

与static_cast 或 reinterpret_cast 相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成 const_cast 和 static_cast 也合法，则其行为与对应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与 reinterpret_cast 类似的功能。

#### 运算符优先级表

|       运算符        | 功能               |
| :-----------------: | ------------------ |
|    typeid(type)     | 类型ID             |
|    typeid(expr)     | 运行时类型ID       |
| ptr->*ptr_to_member | 指向成员选择的指针 |
| obj. *ptr_to member | 指向成员选择的指针 |
|   noexcept (expr)   | 能否抛出异常       |

