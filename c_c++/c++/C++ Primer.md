# C++ Primer

访问main 的返回值的方法依赖于系统。在UNIX 和 Windows系统中，执行完一个程序后,都可以通过echo命令获得其返回值。
在UNIX 系统中,通过如下命令获得状态:

```shell
	$ echo $?
```

在 Windows系统中查看状态可键入:

```shell
$ echo %ERRORLEVEL%
```

**读取数量不定的输入数据**

```c++
#include <iostream>
int main()
{
	int sum = 0,value =0;
	//读取数据直到遇到文件尾，计算所有读入的值的和
	while(std::cin>>value)
	{
		sum +=value;		//等价于 sum = sum+value
	}
	std::cout<< "Sum is: "<<sum<<std::endl;
	return 0;
}
```

while循环条件的求值就是执行表达式：

​	std: :cin >> value

此表达式从标准输入读取下一个数，保存在 value 中。返回其左侧运算对象，在本例中是 std:cin。因此,此循环条件实际上检测的是std.cin。

当我们使用一个istream对象作为条件时,其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符（end-of-file)，或遇到一个无效输入时（例如读入的值不是一个整数),，istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。

因此，我们的while循环会一直执行直至遇到文件结束符（或输入错误)。while循环体使用复合赋值运算符将当前值加到sum上。一旦条件失败，while循环将会结束。我们将执行下一条语句,打印sum的值和一个endl。

**使用文件重定向**

当你测试程序时，反复从键盘敲入这些销售记录作为程序的输入，是非常乏余做。大多数操作系统支持文件重定向，这种机制允许我们将标准输入和标准输出与命名文你关联起来:

```shell
$ addItems <infile >outfile
```

假定 $ 是操作系统提示符，我们的加法程序已经编译为名为 addItems.exe 的可执行文件(在 UNIX中是 addItems)，则上述命令会从一个名为Anfile的文伻读取销售记录，并将输出结果写入到一个名为outfile的文件中，两个文件都位于当前目录中。

**点运算符 .**

点运算只能用于类类型的对象。

**::运算符**

::运算符(::operator）作用域运算符。其用处之一是访问命名空间中的名字。例如,std::cout 表示命名空间 std中的名字cout。

**缓存区**

缓冲区（buffet一个存储区域,用于保存数据。IO设施通常将输入(或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的。我们可以显式地刷新输出缓冲，以便强制将缓冲区中的数据写入输出设备。默认情况下，读cin会刷新cout；程序非正常终止时也会刷新cout。

**Cerr**

Cerr一个 ostream 对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到 cerr的数据是不缓冲的。cerr 通常用于输出错误信息或其他不属于程序正常逻辑的输出内容。

**clog**

clog一个 ostream 对象，关联到标准错误。默认情况下，写到clog的数据是被缓冲的。clog通常用于报告程序的执行信息，存入一个日志文件中。

### 数据类型

数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。

C++ 定义了，基本数据类型包括：算术类型（arithmetic type） 和 空类型（void）。算术类型包含了字符、整形数、布尔值和浮点数。

|    类型     |      含义      |   最小尺寸   |
| :---------: | :------------: | :----------: |
|    bool     |    布尔类型    |    未定义    |
|    char     |      字符      |     8位      |
|   wchar_t   |     宽字符     |     16位     |
|  char16_t   |  Unicode字符   |     16位     |
|  char32_t   |  Unicode字符   |     32位     |
|    short    |     短整型     |     16位     |
|     int     |      整型      |     16位     |
|    long     |     长整型     |     32位     |
|  long long  |     长整型     |     64位     |
|    float    |  单精度浮点数  | 6位有效数字  |
|   double    |  双精度浮点数  | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

基本的字符类型是 char，一个 char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char 的大小和一个机器字节一样。

其他字符类型用于扩展字符集，如 wchar_t、char16_t、char32_t、wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型 char16_t 和 char32_t 则为 Unicode 字符集服务（Unicode 是用于表示所有自然语言中字符的标准）。

​	除字符和布尔类型之外，其他整型用于表示（可能）不同尺寸的整数。C++语言规定一个int至少和一个short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和 一个 long 一样大。其中，数据类型  long long 是在 C++11 中新定义的。



浮点型可表示单精度、双精度和扩展精度值。C++标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，float 以1个字(32比特)来表示，double 以2个字（64比特）来表示，long double 以3或4个字(96或128比特）来表示。一般来说，类型float和double分别有7和16个有效位；类型longdouble则常常被用于有特殊浮点需求的硬件，它的具体实现不同,精度也各不相同。

**类型转换**

特别注意含有无符号类型的表达式，不能出现负数。切勿混用带符号和无符号类型。

**转义字符**

如果反斜线 \ 后面跟着的八进制数字超过3个，只有前3个数字与 \ 构成转义序列。例如，"\1234"表示2个字符，即八进制数123对应的字符以及字符4。相反，\x要用到后面跟着的所有数字，例如，"\x1234" 表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。因为大多数机器的char型数据占8位，所以上面这个例子可能会报错。一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的扩展字符集一起使用的。

**指定字面值的类型**

通过添加如表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。
L'a'				//宽字符型字面值，类型是wchar_t
u8"hi!"		// utf-8字符串字面值（utf-8用8位编码一个Unicode字符）
42ULL		//无符号整型字面值，类型是unsigned long long
1E-3F			//单精度浮点型字面值，类型是float
3.14159L	//扩展精度浮点型字面值，类型是long double

| 前缀 |            含义             |   类型   |
| :--: | :-------------------------: | :------: |
|  u   |       Unicode 16字符        | char16_t |
|  U   |       Unicode 32字符        | char32_t |
|  L   |           宽字符            | wchar_t  |
|  u8  | UTF-8(仅用于字符串字面常量) |   char   |

|   后缀   | 最小匹配类型 |
| :------: | :----------: |
|  u or U  |   unsigned   |
|  l or L  |     long     |
| ll or LL |  long long   |
|  f or F  |    float     |
|  l or L  | long double  |

**列表初始化**

```c++
int units_sold = 0;
int units_sold ={0};
int units_sold{0};
int units_ sold(0);
```

作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用。这种初始化的形式被称为列表初始化（list initialization）。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：

```c++
long double ld = 3.1415926536;
int a{ld},b= {ld};	//错误：转换未执行，因为存在丢失信息的危险
int c(ld),d= ld;		//正确：转换执行，且确实丢失了部分值
```

使用1ong double的值初始化int变量时可能丢失数据，所以编译器拒绝了a和b的初始化请求。其中，至少1d的小数部分会丢失掉，而且int也可能存不下1d的整数部分。

**默认初始值化**

​	如果定义变量时没有指定初值，则变量被默认初始化（default initialized），此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。
​	如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。
​	每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。
​	绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。

**变量声明和定义**

​	声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。
​	变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。
​	如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：

任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了：
extern double pi= 3.1416； //定义
在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。为了支持分离式编译，C++语言将声明和定义区分开来。声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。
变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。
如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：
extern int i;
//声明1而非定义i
int j;
//声明并定义j
任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了：
extern double pi= 3.1416； //定义
在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

```c++
extern int i;		//声明1而非定义i
int j;			//声明并定义j
```

任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了：

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。为了支持分离式编译，C++语言将声明和定义区分开来。声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。
变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。
如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：
extern int i;
//声明1而非定义i
int j;
//声明并定义j
任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了：
extern double pi= 3.1416； //定义
在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

```c++
extern double pi= 3.1416； //定义
```

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

**变量能且只能被定义一次，但是可以被多次声明。**

**静态类型**

C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。

**标识符**

C++的标识符（identifier）由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写字母敏感。

C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。

**C++操作符替代名**

and	bitand	bitor	compl	not_eq	or	or_eg	xor_ eg	and_eq	not	xor

**复合类型**

引用和指针。

**引用**

引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：

```c++
int ival = 1024;
int &refVal = ival;		// refVal指向ival（是ival的另一个名字）
int &refVal2;				//报错：引用必须被初始化
```

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

因为引用本身不是一个对象，所以不能定义引用的引用。

除了2.4.1节和15.2.3节将要介绍的两种例外情况，其他所有引用的**类型**都要和与之绑定的对象严格匹配。而且，引用**只能绑定在对象**上，而不能与字面值或某个表达式的计算结果绑定在一起。

一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

**指针**

指针（pointer）是“指向（point to）”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。

**空指针**

空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：

得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成（参见2.1.2节，

```c++
int *pl= nullptr;			//等价于int *p1= 0；
int *p2=0;					//直接将p2初始化为字面常量0
//需要首先#include cstdlib
int *p3= NULL;			//等价于int *p3=0；
```

得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。另一种办法就如对p2的定义一样，也可以通过将指针初始化为字面值0来生成空指针。
过去的程序还会用到一个名为NULL的预处理变量（preprocessor variable）来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。
现在只要知道预处理器是运行于编译过程之前的一段程序就可以了。预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前面加上std::。
当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用NULL初始化指针和用0初始化指针是一样的。在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL。
把int变量直接赋给指针是错误的操作，即使int变量的值怡好等于0也不行。

```c++
int zero =0;
pi= zero;			//错误：不能把int变量直接赋给指针
```

**void* 指针**

void*是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着-个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解。

利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作 void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。
概括说来，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。

```c++
int* p;			//合法但是容易产生误导
```

我们说这种写法可能产生误导是因为int\*放在一起好像是这条语句中所有变量共同的类型一样。其实恰怡相反，基本数据类型是int而非int\*。仅仅是修饰了p而已，对该声明语句中的其他变量，它并不产生任何作用：

```c++
int* p1,p2;//p1是指向int的指针，p2是int
```

通过*的个数可以区分指针的级别。也就是说，\*\* 表示指向指针的指针，\***表示指向指针的指针的指针，以此类推。

**指向指针的引用**

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```c++
int i=42;
int *p;				//p是一个int型指针
int*&r= p;		//r是一个对指针p的引用
r=&i;				//r引用了一个指针，因此给r赋值&i就是令p指向i
*r=0;			//解引用r得到i，也就是p指向的对象，将i的值改为0
```

要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号*说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。

**面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。**

#### const 限定符

默认情况下，const 对象仅在文件内有效。

当以编译时初始化的方式定义一个const对象时，就如对 bufSize的定义一样：

const int bufSize = 512； //输入缓冲区大小
编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。
	为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了 const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。
	某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。
	解决的办法是，对于 const变量不管是声明还是定义都添加 extern关键字，这样只需定义一次就可以了：

如上述程序所示，file_1.cc定义并初始化了bufSize。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用。
file_1.h头文件中的声明也由 extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。

```c++
// file_1.cc定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h头文件
extern const int bufSize； //与file_1.cc中定义的bufSize是同一个
```

如上述程序所示，file_1.cc定义并初始化了bufSize。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用。
	file_1.h头文件中的声明也由 extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。

**如果想在多个文件之间共享const对象，必须在变量的定义之前添加 extern关键字。**

**const的引用**

可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用（reference to const）。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

因为不允许直接为ci赋值，当然也就不能通过引用去改变ci。因此，对r2的初始化是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确的。

```c++
const int ci=1024;
const int &rl = ci；//正确：引用及其对应的对象都是常量
rl=42;				//错误：r1是对常量的引用
int &r2=ci;		//错误：试图让一个非常量引用指向一个常量对象
```

因为不允许直接为ci赋值，当然也就不能通过引用去改变ci。因此，对r2的初始化是错误的。假设该初始化合法，则可以通过r2来改变它引用对象的值，这显然是不正确的。

**初始化和对 const 的引用**

​	引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：

```c++
int i= 42;.
const int &r1=i;			//允许将const int&绑定到一个普通int对象上
const int &r2= 42;		//正确：r1是一个常量引用
const int &r3 =r1 *2；//正确：r3是一个常量引用
int &r4=r1*2;					//错误：r4是一个普通的非常量引用
```

要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：

```c++
double dval =3.14;
const int &ri= dval;
```

此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式：

```c++
const int temp = dval;		//由双精度浮点数生成一个临时的整型常量
const int &ri = temp;		//让 ri 绑定这个临时量
```

在这种情况下，ri绑定了一个临时量（temporary）对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。
接下来探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则干什么要给ri赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。

**对 const 的引用可能引用一个并非 const 的对象**

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i= 42;
int &rl =i;					//引用ri绑定对象i
const int &r2=i;		 //r2也绑定对象i，但是不允许通过r2修改主的值
rl =0;							// r1并非常量，i的值修改为0
r2=0;							//错误：r2是一个常量引用
```


r2绑定（非常量）整数i是合法的行为。然而，不允许通过 r2 修改 i 的值。尽管如此，i 的值仍然允许通过其他途径修改，既可以直接给 i 赋值，也可以通过像 r1 一样绑定到i的其他引用来修改。

##### 指针和 const

类似于常量引用，指向常量的指针（pointer to const）不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：

2.3.2节（第47页）提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：
double dval =3.14;
// dval是一个双精度浮点数，它的值可以改变
cptr = &dval;
//正确：但是不能通过cptr改变dval的值
和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

```c++
const double pi= 3.14;		// pi是个常量，它的值不能改变
double *ptr = &pi;				//错误：ptr是一个普通指针
const double *cptr = &pi；//正确：cptr可以指向一个双精度常量
*cptr = 42;							 //错误：不能给*cptr赋值
```

指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

```c++
double dval =3.14;			// dval是一个双精度浮点数，它的值可以改变
cptr = &dval;					  //正确：但是不能通过cptr改变dval的值
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

**const 指针**

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：

```c++
int errNumb = 0;
int *const curErr= &errNumb;		// curErr将一直指向errNumb
const double pi=3.14159;
const double *const pip = &pi;			// pip是一个指向常量对象的常量指针
```

##### 顶层const

如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层 const（top-level const）表示指针本身是个常量，而用名词底层const （low-level const）表示指针所指的对象是一个常量。
更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显：

```c++
int i=0;
int *const pl= &i;		  //不能改变p1的值，这是一个顶层const
const int ci= 42;			//不能改变ci的值，这是一个顶层const
const int *p2= &ci;	   //允许改变p2的值，这是一个底层const
const int *const p3 = p2； 	//靠右的const是顶层const，靠左的是底层
constconst int &r = ci;			//用于声明引用的const都是底层const
```

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层 const不受什么影响：

```c++
i= ci;			//正确：拷贝ci的值，ci是一个顶层const，，对此操作无影响
p2= p3;		//正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
```

```c++
int *p=p3;		//错误：p3包含底层const的定义，而p没有
p2=p3;			//正确：p2和p3都是底层const
p2= &i;			//正确：int*能转换成const int*
int &r = ci;		//错误：普通的int&不能绑定到int常量上
const int &r2=i;	//正确：const int&可以绑定到一个普通int上
```

p3既是顶层const也是底层const，拷贝p3时可以不在乎它是一个顶层const，但是必须清楚它指向的对象得是一个常量。因此，不能用p3去初始化p，因为p指向的是一个普通的（非常量）整数。另一方面，p3的值可以赋给p2，是因为这两个指针都是底层const，尽管p3同时也是一个常量指针（顶层const），仅就这次赋值而言不会有什么影响。

**常量表达式**

常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。后面将会提到，C++语言中有几种情况下是要用到常量表达式的。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

```c++
const int max_files = 20;			// max_files是常量表达式
const int limit = max_files +1；// limit是常量表达式
int staff size = 27;						// staff_size不是常量表达式
const int sz = get_size();				//sz 不是常量表达式
```

**constexpr 变量**

C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：

```c++
constexpr int mf = 20;			// 20是常量表达式
constexpr int limit =mf +1;	//mf +1是常量表达式
constexpr int sZ= size();		//只有当size是一个constexpr函数时//才是一条正确的声明语句
```

新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。

**字面值类型**

​	常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。
​	到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类 Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。
​	尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。
​	函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化 constexpr指针。允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr 引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。

**指针和 constexpr**

必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：

```c++
const int *p= nullptr;			//p是一个指向整型常量的指针
constexpr int *q= nullptr;	//q是一个指向整数的常量指针
```

​	p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。
​	与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：

```c++
constexpr int *np - nullptr； 	// np是一个指向整数的常量指针，其值为空
int j=0;
constexpr int i= 42;					 //i的类型是整型常量
//i和j都必须定义在函数体之外
constexpr const int *p= &i； 	//p是常量指针，指向整型常量i
constexpr int *pl=&j;					//p1是常量指针，指向整数j
```

**类型别名**

类型别名（type alias）是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。
有两种方法可用于定义类型别名。传统的方法是使用关键字typedef：

```c++
typedef double wages;		//wages是double的同义词
typedef wages base，*p； //base是double的同义词，p是double*的同义词
```

新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：

```c++
using SI = Sales_item;			// SI是Sales item的同义词
```

这种方法用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。
类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：

```c++
wages hourly, weekly;			//等价于double hourly、weekly；
```

**指针、常量和类型别名**

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char*的别名：

```c++
typedef char *pstring;
const pstring cstr = 0；		// cstr是指向char的常量指针
const pstring *ps;			// ps是一个指针，它的对象是指向char的常量指针
```

上述两条声明语句的基本数据类型都是const pstring，和过去一样，const是对给定类型的修饰。pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。
遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：

再强调一遍：这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。可是用char*重写了声明语句后，数据类型就变成了char，*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

```c++
const char *cstr = 0;	//是对const pstring cstr的错误理解
```

再强调一遍：这种理解是错误的。声明语句中用到pstring时，其基本数据类型是指针。可是用char*重写了声明语句后，数据类型就变成了char，*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

**auto类型说明**

C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如 double）不同，auto 让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值：

```c++
//由vall和val2相加的结果可以推断出item的类型
auto item = vall + val2；// item初始化为vall和val2相加的结果
```

此处编译器将根据val1和val2相加的结果来推断item的类型。如果vall和val2是类Sales_item的对象，则item的类型就是Sales_item；如果这两个变量的类型是double，则item的类型就是double，以此类推。
使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：

```c++
auto i=0,*p= &i;//正确：i是整数、p是整型指针
auto sz =0，pi= 3.14；//错误：sz和pi的类型不一致
```

**复合类型、常量和 auto**

编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。
首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：

```c++
int i=0, &r= i;
auto a=r;		//a是一个整数（r是主的别名，而i是一个整数）
```

其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：

```c++
const int ci=i, &cr = ci;
auto b= ci；	//b是一个整数（ci的顶层const特性被忽略掉了）
auto c = cr； 	//c是一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i； 	//d是一个整型指针（整数的地址就是指向整数的指针）
auto e= &ci； 	//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）
```

如果希望推断出的auto类型是一个顶层const，需要明确指出：

```c++
const auto f = ci;		// ci的推演类型是int，f是const int
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：

```c++
auto &g = ci;		//g是一个整型常量引用，绑定到ci
auto &h=42;		//错误：不能为非常量引用绑定字面值
const auto &j=42;	//正确：可以为常量引用绑定宇面值
```

设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。
要在一条语句中定义多个变量，切记，符号&和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：*

```c++
auto k= ci, &l =i;			//k是整数，1是整型引用
auto &m = ci，*p= &ci；	//m是对整型常量的引用，p是指向整型常量的指针
//错误：i的类型是int而&ci的类型是const int
auto &n = i,*p2 -= &ci;
```

**decltytype 类型**

有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11 新标准引入了第二种类型谠说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：

```c++
decltype(f()) sum = x；// sum的类型就是函数£的返回类型
```

编译器并不实际调用函数£，而是使用当调用发生时£的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如f被调用的话将会返回的那个类型。
decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：

```c++
const int ci=0,&cj= ci;
decltype (ci) x=0;		//x的类型是const int
decltype(cj) y= x;		//y的类型是const int&，y绑定到变量x
decltype(cj) z;			//错误：z是一个引用，必须初始化
```

因为 cj 是一个引用，decltype(cj) 的结果就是引用类型，因此作为引用的z必须被初始化。
需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在 decltype处是一个例外。

**decltype 和引用**

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：

```c++
// decltype的结果可以是引用类型
int i- 42,*p= &i, &r = i;
decltype(r +0) b；	//正确：加法的结果是int，因此b是一个（未初始化的）int
decltype(*p) c;		  //错误：c是int&，必须初始化
```

​	因为r是一个引用，因此decltype （r）的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。
​	另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype（*p）的结果类型就是int&，而非int。
​	decltype 和auto的另一处重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于 decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果 decltype 使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype 就会得到引用类型：

```c++
// decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d;		//错误：d是int&，必须初始化
decltype(i) e;		  //正确：e是一个（未初始化的）int
```

**切记：decltype((variable)) （注意是双层括号）的结果永远是引用，而 decltype(variable) 结果只有当 variable 本身就是一个引用时才是引用**。



**自定义数据结构**

struct  和 class 的使用。struct 只含数据元素结构，不包含方法。

##### 预处理器概述

确保头文件多次包含仍能安全工作的常用技术是预处理器（preprocessor），它由 C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到了一项预处理功能#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。
C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
使用这些功能就能有效地防止重复包含的发生：

```c++
#ifndef SALES DATA H
#define SALES DATAH
#include <string>

struct Sales_data {
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue =0.0;
};
#endif
```

**预处理变量无视 c++ 语言中关于作用域的规则**。

### 字符串、向量和数组

C++ 的抽象数据类型，string和vector是两种最重要的标准库类型，前者支持可变长字符串，后者则表示可变长的集合。还有一种标准库类型是迭代器，它是string 和 vector的配套类型，常被用于访问string中的字符或vector中的元素。内置数组是一种更基础的类型，string和 vector都是对它的某种抽象。

**命名空间的 using 声明**

有了using 声明就无须专门的前缀（形如命名空间：：）也能使用所需的名字了。using声明具有如下的形式：
using namespace::name;
一旦声明了上述语句，就可以直接访问命名空间中的名字：

```c++
#include <iostream>
// using声明，当我们使用名字cin时，从命名空间std中获取它
using std::cin;
int main()
{
	int i;
	cin >> i;
	//正确：cin和std：：cin含义相同
	cout << i;
	//错误：没有对应的using声明，必须使用完整的名字
	std::cout << i；//正确：显式地从std中使用cout
	return 0;
}
```

**头文件不应包含 using 声明**

位于头文件的代码一般来说不应该使用using 声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

#### 标准库类型 string

标准库类型 string表示可变长的字符序列，使用 string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。接下来的示例都假定已包含了下述代码：

```c++
#include <string>
using std::string;
```

**初始化 string 对象的方式**

```
string sl			默认初始化，s1是一个空串
string s2 (s1)		s2是s1的副本
string s2 = sl		等价于s2(s1)，s2是s1的副本
string s3 ("value") s3是字面值"value"的副本，除了字面值最后的那个空字符外
string s3 = "value"	等价于s3（"value"），s3是字面值"value"的副本
string s4(n, 'c')	把s4初始化为由连续n个字符c组成的串
```

**直接初始化和拷贝初始化**

如果使用等号（=）初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化(direct initialization)。

**string 对象上的操作**

```c++
0s<<s			将s写到输出流os当中，返回os
is>>s			 从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is,s)  从is中读取一行赋给s，返回is
s.empty()	  s为空返回true，否则返回false
s.size()			返回s中字符的个数
s[n]				 返回s中第n个字符的引用，位置n从0计起
s1+s2			  返回s1和s2连接后的结果
sl=s2				用s2的副本代替s1中原来的字符
sl==s2				如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感
s1!=s2
<,<=,>,>=		利用字符在字典中的顺序进行比较，且对字母的大小写敏感
```

触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符。

**string 相加**

字面值和 string 相加

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string：

```c++
string s4 =s1 +",";		//正确：把一个string对象和一个字面值相加
string s5 = "hello" +"，"；	//错误：两个运算对象都不是string
//正确：每个加法运算符都有一个运算对象是string
string s6=sl +","+ "world";
string s7 = "hello"+"，"+ s2；	 //错误：不能把字面值直接相加
```

s6的初始化形式之前没有出现过，但其实它的工作机理和连续输入连续输出是一样的，可以用如下的形式分组：

```c++
string s6 = (s1 +",") +"world";
```

其中子表达式s1 +"，"的结果是一个string对象，它同时作为第二个加法运算符的左侧运算对象，因此上述语句和下面的两个语句是等价的：

```c++
string tmp=s1 +"，"；	//正确：加法运算符有一个运算对象是string
s6= tmp + "world";		 //正确：加法运算符有一个运算对象是string
```

**因为某些历史原因，也为了与C兼容，所以 C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串宇面值与string是不同的类型。**

在 cctype头文件中定义了一组标准库函数处理这部分工作，表3.3列出了主要的函数名及其含义。cctype 头文件中的函数：

|    函数     | 函数说明                                                     |
| :---------: | ------------------------------------------------------------ |
| isalnum(c)  | 当c是字母或数字时为真                                        |
| isalpha (c) | 当c是字母时为真                                              |
| iscntrl(c)  | 当c是控制字符时为真                                          |
| isdigit(c)  | 当c是数字时为真                                              |
| isgraph (c) | 当c不是空格但可打印时为真                                    |
| islower(c)  | 当c是小写字母时为真                                          |
| isprint(c)  | 当c是可打印字符时为真（即c是空格或c具有可视形式）            |
| ispunct(c)  | 当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种） |
| isspace(c)  | 当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） |
| isupper(c)  | 当c是大写字母时为真                                          |
| isxdigit(c) | 当c是十六进制数字时为真                                      |
| tolower(c)  | 如果c是大写字母，输出对应的小写字母；否则原样输出c           |
| toupper(c)  | 如果c是小写字母，输出对应的大写字母；否则原样输出c           |

**注意：**

一般来说，C++程序应该使用名为cname 的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。

**范围 for**

范围for （range for）语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：

```c++
for (declaration : expression)
	statement
```

如果想要改变string对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。

```c++
string s("Hello World!!!");
//转换成大写形式。
for (auto &c : s)
	//对于s中的每个字符（注意：c是引用）
	c = toupper (c);
	//c是一个引用，因此赋值语句将改变s中字符的值
cout << s << endl;
```

如果某个索引是带符号类型的值将自动转换成由 string::size_type 表达的无符号类型。

#### vector

标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector “容纳着” 其他对象，所以它也常被称作容器（container）。

```c++
#include <vector>
using std::vector;
```

C++语言既有类模板 （class template），也有函数模板，其中vector是一个类模板。

对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息。
以vector为例，提供的额外信息是vector内所存放对象的类型：

```c++
vector<int> ivec;	// ivec保存int类型的对象
vector<Sales_item> Sales_vec;	//保存Sales_item类型的对象
vector<vector<string>> file;	//该向量的元素是vector对象
```

在上面的例子中，编译器根据模板 vector 生成了三种不同的类型： vector<int\>、vector<Sales item\>和vector<vector<string\>>。

vector 是模版而非类型，由 vector 生成的类型必须包含 vector 中元素的类型，例如 vector<int\>。

vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成 vector对象，甚至组成vector的元素也可以是vector。

**定义和初始化 vector 对象**

|           函数           | 函数说明                                                |
| :----------------------: | ------------------------------------------------------- |
|      vector<T\> v1       | v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 |
|    vector<T\> v2(v1)     | v2中包含有v1所有元素的副本                              |
|     vector<T\> v2=v1     | 等价于v2（v1），v2中包含有v1所有元素的副本              |
|  vector<T\> v3(n, val)   | v3包含了n个重复的元素，每个元素的值都是val              |
|     vector<T\> v4(n)     | v4包含了n个重复地执行了值初始化的对象                   |
| vector<T\> v5{a,b,c...}  | v5包含了初始值个数的元素，每个元素被赋予相应的初始值    |
| vector<T\> v5={a,b,c...} | 等价于v5{a，b，c...}                                    |

**列表初始化**

```c++
vector<string> articles = {"a", "an", "the"};
```

如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里：

```c++
vector<string> v1{"a","an","the"};	//列表初始化
vector<string> v2("a","an""the");	//错误
```

另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector对象了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要列表初始化 vector对象的元素还是用给定的容量值来构造 vector对象：

```c++
vector<string> v5{"hi"}；	//列表初始化：v5有一个元素
vector<string> v6("hi"); 	//错误：不能使用字符串字面值构建vector对象
vector<string>v7{10};		//v7有10个默认初始化的元素
vector<string>v8{10, "hi"};	//v8有10个值为"hi"的元素
```

尽管在上面的例子中除了第二条语句之外都用了花括号，但其实只有v5是列表初始化。要想列表初始化 vector对象，花括号里的值必须与元素类型相同。显然不能用int初始化string对象，所以 v7 和 v8 提供的值不能作为元素的初始值。确认无法执行列表初始化后，编译器会尝试用默认值初始化 vector对象。

**添加元素**

push_back向其中添加元素。push_back负责把一个值当成vector对象的尾元素“压到（push）”vector对象的“尾端（back）”。例如：

```c++
vector<int> v2;	//空vector对象
for (int i = 0; i != 100; ++i)
	v2.push_back（i）；//依次把整数值放到v2尾端
```

**注意：**

如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。范围 for 语句体内不应改变其所遍历序列的大小。

**其他 vector 操作**

|       函数       | 函数说明                                                     |
| :--------------: | ------------------------------------------------------------ |
|    v.empty()     | 如果v不含有任何元素，返回真；否则返回假                      |
|     v.size()     | 返回v中元素的个数                                            |
|  v.push_back(t)  | 向v的尾端添加一个值为七的元素                                |
|       v[n]       | 返回v中第n个位置上元素的引用                                 |
|      v1=v2       | 用v2中元素的拷贝替换v1中的元素                               |
| v1= {a，b，c...} | 用列表中元素的拷贝替换v1中的元素                             |
|      vl==v2      | v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
|      v1!=v2      |                                                              |
|    <，<=,>,>=    | 顾名思义，以字典顺序进行比较                                 |

要使用 size_ type，需首先指定它是由哪种类型定义的。vector 对象的类型总是包含着元素的类型：

```c++
vector<int>::size_type		//正确
vector::size type			//错误
```

**不能用下标形式添加元素**

下面的代码试图为vector对象ivec添加10个元素：

```c++
vector<int> ivec; //空 vector对象
for (decltype (ivec.size())ix =0;ix != 10;++ix)
	ivec[ix] = ix； //严重错误：ivec不包含任何元素
```

然而，这段代码是错误的：ivec是一个空 vector，根本不包含任何元素，当然也就不能通过下标去访问任何元素！如前所述，正确的方法是使用push_back：

```c++
for (decltype(vec.size())ix = 0;ix!= 10; ++ix)
	ivec.push_ back(ix);//正确：添加一个新元素，该元素的值是ix
```

vector 对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。

#### 迭代器

类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者 string 对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

##### 使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin 和 end的成员，其中begin 成员负责返回指向第一个元素（或第一个字符）的迭代器。如有下述语句：

```c++
//由编译器决定b和e的类型；参见2.5.2节（第61页）
//b表示v的第一个元素，e表示v尾元素的下一位置
auto b=v.begin（），e=v.end（）；//b和e的类型相同
```

end成员则负责返回指向容器（或string对象）“**尾元素的下一位置（one past the end）**”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“尾后（off the end）”元素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器常被称作尾后迭代器（off-the-end iterator）或者简称为尾迭代器（end iterator）。特殊情况下如果容器为空，则begin 和 end返回的是同一个迭代器。

**如果容器为空，则begin 和end返回的是同一个迭代器，都是尾后迭代器。**

**迭代器运算符**

|    运算符     | 运算符说明3                                                  |
| :-----------: | ------------------------------------------------------------ |
|     *iter     | 返回迭代器iter所指元素的引用                                 |
|   iter->mem   | 解引用iter并获取该元素的名为mem的成员，等价于（*iter）.mem   |
|    ++iter     | 令iter指示容器中的下一个元素                                 |
|    --iter     | 令iter指示容器中的上一个元素                                 |
| iterl==iter2  | 判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等； |
| iterl!= iter2 | 反之，不相等                                                 |

**注意**：

原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使 **用 != 而非 <** 进行判断有点儿奇怪。C++程序员习惯性地使用 != ，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。
之前已经说过，只有string 和 vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了 == 和 != ，但是它们中的大多数都没有定义 < 运算符。因此，只要我们养成使用迭代器和 != 的习惯，就不用太在意用的到底是哪种容器类型。

**迭代器类型**

就像不知道 string和 vector的size_type成员到底是什么类型一样，一般来说我们也不知道（其实是无须知道）迭代器的精确类型。而实际上，那些拥有迭代器的标准库类型使用iterator 和const_iterator来表示迭代器的类型：

```c++
vector<int>::iterator it;	//it能读写vector<int>的元素
string::iterator it2;	//it2能读写string对象中的字符
vector<int>::const_iterator it3;	// it3只能读元素，不能写元素
string::const_iterator it4;	// it4只能读字符，不能写字符
```


const_iterator 和常量指针（参见2.4.2节，第56页）差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果 vector对象或string对象是一个常量，只能使用const iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const iterator。

**begin 和 end 运算符**

begin 和 end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator。

```c++
vector<int> v;
const vector<int> cv;
auto itl = v.begin();	//itl的类型是vector<int>::iterator
auto it2 = cv.begin();	//it2的类型是vector<int>::const_iterator
```

有时候这种默认的行为并非我们所要。如果对象只需读操作而无须写操作的话最好使用常量类型（比如const _iterator）。为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是**cbegin**和 **cend**：

类似于 begin 和 end，上述两个新函数也分别返回指示容器第一个元素或最后元素下一位置的迭代器。有所不同的是，不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

```c++
auto it3 = v.cbegin（）；// it3的类型是vector《int》：：const_iterator
```

类似于 begin 和 end，上述两个新函数也分别返回指示容器第一个元素或最后元素下一位置的迭代器。有所不同的是，不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

**结合解引用和成员访问操作**

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。例如，对于一个由字符串组成的vector对象来说，要想检查其元素是否为空，令it是该vector对象的迭代器，只需检查it所指字符串是否为空就可以了，其代码如下所示：

```c++
(*it).empty()
```

注意，(\*it).empty() 中的圆括号必不可少，该表达式的含义是先对 it 解引用，然后解引用的结果再执行点运算符。如果不加圆括号，点运算符将由 it 来执行，而非it解引用的结果：

```c++
(*it).empty()
//解引用it，然后调用结果对象的empty成员
*it.empty()
//错误：试图访问it的名为empty的成员，但it是个迭代器，//没有empty成员
```

上面第二个表达式的含义是从名为it的对象中寻找其 empty成员，显然it是一个迭代器，它没有哪个成员是叫empty的，所以第二个表达式将发生错误。
为了简化上述表达式，C++语言定义了箭头运算符(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it->mem和 (*it).mem 表达的意思相同。

```c++
//依次输出text的每一行直至遇到第一个空白行为止
for (auto it = text.cbegin() ;it != text.cend() && !it->empty(); ++it)
    cout << *it << endl;
```

**某些对vector对象的操作会使迭代器失效**

虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如 push_back，都会使该vector对象的迭代器失效。将详细解释迭代器是如何失效的。

**但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素**。

**迭代器运算**

| 运算符        | 运算符说明                                                   |
| ------------- | ------------------------------------------------------------ |
| iter +n       | 迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置 |
| iter -n       | 迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置 |
| iterl+=n      | 迭代器加法的复合赋值语句，将iter1加n的结果赋给iterl          |
| iterl -=n     | 迭代器减法的复合赋值语句，将iterl减n的结果赋给iter1          |
| iterl - iter2 | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭<br/>代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置 |
| \>、>=、<、<= | 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置 |

对于 string 或 vector 的迭代器来说，除了判断是否相等，还能使用关系运算符（<、<=、>、>=）对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。

所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和vector都定义了difference_type，因为这个距离可正可负，所以difference_type是带符号类型的。

#### 数组

数组是一种类似于标准库类型 vector 的数据结构，但是在性能和灵活性的权衡上又与 vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。

##### 定义和初始化内置数组

数组是一种复合类型。数组的声明形如a[d]，其中a是数组的名字，d是数组的维度。维度说明了数组中元素的个数，因此必须大于0。数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式：

```c++
unsigned cnt = 42;	//不是常量表达式
constexpr unsigned sz= 42;	//常量表达式
int arr[10];	//含有10个整数的数组
int *parr[sz];	//含有42个整型指针的数组
string bad[cnt];	//错误：cnt不是常量表达式
string strs[get_size()]; //当get_size是constexpr时正确；否则错误
```

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和 vector 一样，数组的元素应为对象，因此不存在引用的数组。

**字符数组的特殊性**

字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：

```c++
char al[] ={'C','+','+'};	//列表初始化，没有空字符
char a2[] ={'C','+','+','0'};	//列表初始化，含有显式的空字符
char a3[]="C++";	//自动添加表示字符串结束的空字符
const char a4[6]="Daniel";	//错误：没有空间可存放空字符！
```

**不允许拷贝和赋值**

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```c++
int a[] ={0,1,2};	//含有3个整数的数组
int a2[]=a;	//错误：不允许使用一个数组初始化另一个数组
a2= a;	//错误：不能把一个数组直接赋值给另一个数组
```

**一些编译器支持数组的赋值，这就是所谓的编译器扩展（compiler extension）。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。**

