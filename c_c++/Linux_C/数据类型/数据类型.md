### 数据类型

数据类型包含两方面的内容----数据的表示和对数据加工的操作。

数据类型分为：基本数据类型、构造类型、指针类型、枚举类型和空类型。

#### 变量

变量的值不回因为变量的类型发生了改变而改变，当变量被转换为对应类型时，内存区域的二进制序列以该类型的形式翻译出来。这也是强制类型转换能够成立的原因。

##### 全局变量

在函数中使用全局变量，一般应作全局变量说明，只有在函数内经过说明的全局变量才能使用。全局变量的说明符为 extern，但在一个函数之前定义的全局变量，在该函数内使用可不再加以说明。

#### 基本的内置类型

- 整型
- 实型
- 构造类型
- 指针类型
- 枚举类型
- void类型

##### void 类型

可以表示没有数据(没有结果，没有形式参数)；也可以表示某种任意类型的数据(如又与指针结合，用void * 标记)。程序如要使用 void* 类型的数据，应该将它强转成某种具体的指针类型。

##### 数据类型的大小

| 类型说明符         | 字节数 |
| ------------------ | ------ |
| int                | 4      |
| unsigned int       | 4      |
| short int          | 2      |
| unsigned short int | 2      |
| long int           | 4      |
| unsigned long      | 4      |
| char               | 1      |
| unsigned char      | 1      |

#### 声明与定义

定义：

​	就是（编译器）创建一个对象，为这个对象分配一块内存并给它取上一个名字。

声明：声明可以出现多次

 	1. 告诉编译器，这个名字已经匹配到一块内存上了。
   	2. 告诉编译器，这个名字我先预定了，别的地方再也不能用它来作为变量名或对象名。

#### static 与 extern

##### static

变化：

​	生命周期

​	存储空间

不变化：

​	作用域

特点：

​	只初始化一次

​	有默认值（静态局部变量）

使用static修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束为止。虽然用 static 对局部变量进行修饰过后，其生命周期和存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。

##### extern

extern 是指当前变量或函数不是在本源文件内声明的，它是外部变量或外部函数。

如果有一个以上源文件对同一个变量进行了初始化，则报错。

在任何函数体外声明或定义变量时，不加 extern 可以是定义也可能是声明，编译器选择初始化的那个（最多一个地方对它进行了初始化），如果没有初始化则选择其中一个作为定义，其他为声明，但是加extern肯定是声明；如果不想让其他源文件链接到，则需要使用 static。

#### const

辨别使用技巧：

1. 将类型去掉
2. 看const修饰谁，谁就拥有了铁布衫，谁的值就是不能修改的，是readonly的。

#### auto

auto的出现意味着当前变量的作用域为当前函数或代码段的局部变量，意味着当前变量会在内存栈上进行分配。

注：

​	有的编译器为了提高效率，在出栈时不会进行数据清空，这也就意味着，下个函数里的变量在入栈使用该空间时，里面的数据是上一次变量操作的结果。

#### register

##### 作用

寄存器变量，让该变量的访问速度达到最快。

##### 注意

1. 待声明为寄存器变量类型应该是 CPU寄存器所能接收的类型，意味着寄存器变量是单个变量，变量长度应该小于等于寄存器长度
2. 不能对寄存器变量使用取地址符"&"，因为该变量没有内存地址
3. 尽量在大量频繁操作时使用寄存器变量，且声明的变量个数应该尽量少

#### volatile

volatile 强烈请求编译器要老老实实地在每次对变量进行访问时去内存里读取。

#### typedef

作用：为一种类型定义一个新名字。这里的数据类型包括内部数据类型(如 int、char 等)和自定义的数据类型(如 struct)

##### typedef 与 #define的区别

\#define 是直接替换；typedef 则是为一个类型起新名字。

typedef，它符合范围规则，使用typedef 定义的变量类型，其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。

#### 枚举

```
enum enum_type_name{
	ENUM_CONST_1,
	ENUM_CONST_2,
	...
	ENUM_CONST_N
}enum_variable_name;
```

枚举与#define宏的区别

1. \#define 宏常量是在预编译阶段进行简单替换，枚举常量则是在编译的时候确定其值
2. 一般在编译器里，可以调试枚举常量，但是不能调试宏常量
3. 枚举可以一次定义大量相关的常量，而\#define宏一次只能定义一个

#### 联合体

```
union 联合名{
	int a;
	char office[10];
};
```

联合体成员变量的应用和结构体成员变量的引用很相近，格式为：

> 联合体变量.成员变量名

##### union经典使用

大端和小端的问题

```
union w{
	int a;
	char b;
}c;
```

