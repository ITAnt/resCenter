## shell 编程

#### shell

shell 就是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 shell来启动、挂起、停止，甚至编写一些程序。

#### 几种流行的shell

目前流行的 shell：

- ash
- bash
- ksh
- csh
- zsh

查看 shell 的类型

> echo $SHELL

#### shell程序设计

##### shell基本语法

###### 输入输出重定向

> common > file：将命令的输出结果重定向到一个文件

###### 管道pipe

可以将某一个程序的输出送到另一个程序的输入

> command1 | command2 [|command3 ....]

也可以连同标准错误输出一起送入管道

> command1 | &command2 [|& command3 ...]

###### 前台和后台

一个新产生的进程可以通过用命令后面的符号 ";" 和 “&” 来分别以前台和后台的方式来执行

> command

产生一个前台的进程，下一个命令须等该命令运行结束后才能输入

> command &

产生一个后台的进程，此进程在后台运行的同时，可以输入其他的命令

##### shell程序的变量和参数

对于 shell来讲，所有变量的取值都是一个字符串，shell 程序采用 $var 的形式来引用名为 var 的变量的值。shell有以下几种基本类型的变量。

###### shell 定义的环境变量

常见的 shell 环境变量有

- HOME：用于保存注册目录的完全路径名
- PATH：用于保存用冒号分隔的目录路径名，shell 将按 PATH 变量中给出的顺序搜索这些目录，找到的第一个与命令名称一致的可执行文件将被执行
- TERM：终端的类型
- UID：当前用户的标识符，取值是由数字构成的字符串
- PWD：当前工作目录的绝对路径名，该变量的取值随 cd 命令的使用而变化
- PS1：主提示符，在特权用户下，默认的主提示符是 "#"；在普通用户下，默认的主提示符是 “$”
- PS2：在 shell 接收用户输入命令的过程中，如果用户在输入行的末尾输入"\\"然后回车，或者当用户按回车键时 shell 判断出用户输入的命令没有结束时，显示这个辅助提示符，提示用户继续输入命令的其余部分，默认的辅助提示符是 ">"。

###### 用户定义的变量

> 变量名=变量值

在定义变量时，变量名前不应加符号"$"，在引用变量的内容时则应在变量名前加“\$”；在给变量赋值时，等号两边一定不能留空格，若变量中本身就包含了空格，则整个字符串都要用双引号括起来。

> readly 变量名

变量的只读性。

> export 变量名

export 命令可以将一局部变量提供给 shell 执行的其他命令使用。

##### 位置参数

位置参数是一种在调用 shell 程序的命令行中按照各自的位置决定的变量，是在程序名之后输入的参数。位置参数之间用空格分隔，shell取第一个位置参数替换程序文件中的 \$1，第二个替换 \$2，依次类推。\$0是一个特殊的变量，它的内容是当前这个 shell 程序的文件名，所以，\$0 不是一个位置参数，在显示当前所有的位置参数时是不包括 \$0。

##### 预定义变量

预定义变量和环境变量相类似，也是在 shell 一开始时就定义了的变量，所不同的是，用户只能根据 shell 的定义来使用这些变量，而**不能重定义**它。所有预定义变量都是由 \$ 符号和另一个符号组成的，常用的 shell 预定义变量有：

- \$#：位置参数的数量
- \$*：所有位置参数的内容
- \$?：命令执行后返回的状态
- \$\$：当前进程的进程号
- \$!：后台运行的最后一个进程号
- \$0：当前执行的进程名

其中，“$?”用于检查上一个命令执行是否正确(在 Linux 中，命令退出状态为 0 表示该命令正确执行，任何非 0值表示命令出错)；“\$\$”变量最常见的用途是用作临时文件的名字以保证临时文件不会重复。

##### 参数置换的变量

参数置换的变量有四种，这些变量通常与某一个位置参数相联系，根据指定的位置参数是否已经设置类决定变量的取值，它们的语法和功能分别如下：

1. 变量=\${参数-word}：如果设置了参数，则用参数的值置换变量的值，否则用 word 置换。即这种变量的值等于某一个参数的值，如果该参数没有设置，则变量等于 word 的值。
2. 变量=\${参数=word}：如果设置了参数，则用参数的值置换变量的值，否则把变量设置成 word，然后用 word 替换参数的值。注意，位置参数不能用于这种方式，因为在 shell 程序中不能为位置参数赋值。
3. 变量=\${参数?word}：如果设置了参数，则用参数的值置换变量的值，否则就显示 word 并从 shell 中退出；如果省略了 word，则显示标准信息。这种变量要求一定等于某一个参数的值，如果该参数没有设置，就显示一个信息，然后退出，因此这种方式常用于出错指示。
4. 变量=\${参数+word}：如果设置了参数，则用 word 置换变量，否则不进行置换。

#### shell 程序设计的流程控制

shell编程的流程控制、调试方法及shell程序的运行方法。

##### test测试命令

test命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试，某测试符和相应的功能分别如下。

###### 数值测试

- -eq：等于则为真
- -ne：不等于则为真
- -gt：大于则为真
- -ge：大于等于则为真
- -lt：小于则为真
- -le：小于等于则为真

###### 字符串测试

- =：等于则为真
- !=：不相等则为真
- -z 字符串：字符串长度伪则为真
- -n 字符串：字符串长度不伪则为真

###### 文件测试

- -e 文件名：如果文件存在则为真
- -r 文件名：如果文件存在且可读则为真
- -w 文件名：如果文件存在且可写则为真
- -x 文件名：如果文件存在且可执行则为真
- -s 文件名：如果文件存在且至少有一个字符则为真
- -d 文件名：如果文件存在且为目录则为真
- -f 文件名：如果文件存在且为普通文件则为真
- -c 文件名：如果文件存在且为字符型特殊文件则为真
- -b 文件名：如果文件存在且为块特殊文件则为真

Linux 还提供了与(!)、或(-o)、非(-a)三个逻辑操作符用于将测试条件连接起来，其优先级为 "!"最高，“-a“次之，“-o”最低。

同时，bash 也能完成简单的算术运算，格式如下：

> $[expression]

例如：

```shell
var1=2
var2=$[var1*10+1]
```

##### if 条件语句

> if 条件命令串
>
> then
>
> ​	条件为真时的命令串
>
> else
>
> ​	条件为假时的命令串
>
> fi

##### for循环

> for 变量名
>
> [in 数值列表]
>
> do
>
> ​	若干个命令行
>
> done

变量名可以是用户选择的任何字符串，如果变量名是 var，则在 in 之后给出的数值将顺序替换循环命令列表中 \$var。如果省略了 in，则变量var 的取值将是位置参数。

##### while 和 until 循环

while 和 until 命令都是用命令的返回状态值来控制循环的。while 循环的一般格式为

> while
>
> ​	若干个命令行1
>
> do
>
> ​	若干个命令行2
>
> done

untile 命令是另一种循环结构，它和 while 命令相似，其格式为

> until
>
> 若干个命令行1
>
> do
>
> ​	若干个命令行2
>
> done

until 循环和 while 循环的区别在于：while循环在条件为真时继续执行循环，而 until 则是在条件为假时继续执行循环。

shell 还提供了 true 和 false 两条命令，用于建立无限循环结构，它们的返回状态分别是总为0或总为非0。

##### case 条件选择

case 条件选择为用户提供了根据字符串或变量的值从多个选项中选择一项的方法，其格式为：

> case string in
>
> exp-1)
>
> ​	若干个命令行1
>
> ;;
>
> exp-2)
>
> ​	若干个命令行2
>
> ;;
>
> .......
>
> *)
>
> 其他命令行
>
> esac

shell通过计算字符串 string 的值，将其结果依次和表达式 exp-1、exp-2 等进行比较，直到找到一个匹配的表达式为止，如果找到了匹配项则执行它下面的命令，直到遇到一对分号(;;)为止。

在case 表达式中也可以使用 shell 的通配符("*"、“?”、“[ ]”)，通常用"\*"作为 case 命令的最后表达式，以便使在前面找不到任何相应的匹配项时执行“其他命令”的命令。

##### 无条件控制语句 break 和 continue

break 用于立即终止当前循环的执行，而 continue 用于不执行循环中后面的语句而立即开始下一个循环的执行。这两个语句只有放在 do 和 done 之间时才有效。

##### 函数定义

函数定义的基本格式为：

> functionname
>
> {
>
> ​	若干个命令行	
>
> }

调用函数的格式为

> functionname param1 param2...

shell 函数可以完成某些例行的工作，而且还可以有自己的退出状态，因此函数也可以作为 if、while 等控制结构的条件。

在函数定义时不用带参数说明，但在调用函数时可以带有参数，此时 shell 将把这些参数分别赋予相应的位置参数 \$1、\$2、....、\$* 。

#### 命令分组

在shell 中有两种命令分组的方法——() 和 {}。

- ()：当shell 执行 () 中的命令时将再创建一个新的子进程，然后这个子进程去执行圆括弧中的命令。当用户在执行某个命令时不想让命令运行时对状态集合（如位置参数、环境变量、当前工作目录等）的改变影响到下面语句的执行时，就应该把这些命令放在圆括弧中，这样就能保证所有的改变只对子进程产生影响，而父进程不受任何干扰
- {}：用于将顺序执行的命令的输出结果用于另一个命令的输入（管道方式）。当我们要真正使用圆括弧和花括弧时（如计算表达式的优先级），则需要在其前面加上转义符(\\)；以便让 shell 知道它们不是用于命令执行的控制所用。

#### 信号

trap 命令用于在 shell 程序中捕捉到信号，之后可以有三种反应方式。

- 执行一段程序来处理这一信号

  在 shell 接收到 signal list 清单中数值相同的信号时，将执行双引号中的命令串。

  ```shell
  trap 'commands' signal-list
  trap "commands" signal-list
  ```

- 接收信号的默认操作

  为了恢复信号的默认操作

  ```shell
  trap signal-list
  ```

- 忽视这一信号

  忽视这一信号

  ```shell
  trap " " signal-list
  ```

##### 注意

1. 对信号11(段违例)不能捕捉，因为 shell 本身需要捕捉该信号去进行内存的转存。
2. 在 trap 中可以定义对信号 0 的处理（实际上没有这个信号），shell程序在其终止（如执行 exit 语句）时发出该信号
3. 在捕捉到 signal-list 中指定的信号并执行完相应的命令之后，如果这些命令没有将 shell 程序终止的话，shell 程序将继续执行收到信号时所执行的命令后面的命令，这样将很容易导致 shell 程序无法终止

另外，在 trap 语句中，单引号和双引号是不同的，当 shell程序第一次碰到 trap 语句时，把 commands 中的命令扫描一遍，此时若 commands 是用单引号括起来的话，那么 shell 不会对 commands 中的变量和命令进行替换；否则 commands 中的变量和命令将用当时具体的值来替换。

#### 运行 shell 程序的方法

1. sh shell 程序文件名

   > bash shell 程序文件名

2. sh

   > bash

3. 用 chmod 命令使 shell程序成为可执行的，然后直接键入文件名即可

#### bash程序的调试

shell程序的调试主要是利用 bash 命令解释程序的选择项。调用 bash 的形式为：

> bash -选择项 shell 程序文件名

几个常用的选择项如下：

- -e：如果一个命令失败就立即退出
- -n：读入命令但是不执行它们
- -u：置换时把未设置的变量看作出错
- -v：当读入 shell 输入行时把它们显示出来
- -x：执行命令时把命令和它们的参数显示出来

上面的所有选项也可以在 shell 程序内部用“set -选择项”的形式引用，而"set+选择项"则将禁止该选择项起作用。

在执行命令行之前无 “-v” 则打印出命令行的原始内容，而有 “-v”则打印出经过替换后的命令行的内容。

#### bash 的内部命令

内部命令在目录列表中是看不到的，它们由 shell 本身提供。常用的内部命令有 echo、eval、exec、export、readonly、read、shift、wait 和点 “.” 。

##### echo

> echo arg

在屏幕上打印出由 arg 指定的字符串

##### eval

> eval args

当shell程序执行到 eval 语句时，shell 读入参数 args ，并将它们组合成一个新的命令，然后执行

##### exec

> exec 命令 命令参数

当shell 执行到 exec 语句时，不会去创建新的子进程，而是转去执行指定的命令，当指定的命令执行完时，该进程，也就是最初的 shell 就终止了，所以 shell 程序中 exec 后面的语句将不再被执行。

##### export

> export 变量名或：export 变量名=变量值

shell 可以用 export 把它的变量向下带入子 shell，从而让子进程继承父进程中的环境变量，但子 shell 不能用 export 把它的变量向上带入父 shell 。注意：不带任何变量名的 export 语句将显示出当前所有的 export 变量。

##### readonly

> readonly 变量名

将一个用户定义的 shell 变量标识为不可变的，不带任何参数的 readonly 命令将显示出所有只读的 shell变量

##### read

> read 变量名表

从标准输入设备读入一行，分解成若干字，赋值给 shell 程序内部定义的变量。

##### shift

shift 语句按如下方式重新命名所有的位置参数变量，\$2 成为 \$1，\$3 成为\$2 ...... 在程序中每使用一次 shift 语句，都使所有的位置参数依次向左移动一个位置，并使位置参数 "\$#" 减1，直到减到 0。

##### wait

shell 等待在后台启动的所有子进程结束，wait 的返回值总是真。

##### exit

退出 shell 程序，在 exit 之后可有选择地指定一个数字作为返回状态。

##### .

> . shell程序文件名

使 shell 读入指定的 shell 程序文件并依次执行文件中的所有语句。