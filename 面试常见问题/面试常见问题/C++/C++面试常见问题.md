## C++面试常见问题

### STL

vector封装数组，list封装了链表

标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树:红黑树

dequeue 介于 vector 和 list 之间，由于中控器

C++11引入 unordered_map、unordered_set 和 array

##### 关联容器

为何map和set的插入删除效率比用其他序列容器高?

因为对于关联容器来说，不需要做内存拷贝和内存移动。

为何每次insert之后，以前保存的iterator不会失效?

iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。

因为是排序的，所以set中的元素不能被修改，只能删除后再添加。

因为是排序的，所以map中元素的key不能被修改，只能删除后再添加。key对应的value可以修改。





#### 多态与虚函数

虚函数的实现：在有虚函数的类中，类的最开始部分是一个**虚函数表的指针**，这个指针指**向一个虚函数表**，**表中放了虚函数的地址**，实际的虚函数在代码段(.text)中。当**子类继承了父类**的时候也**会继承其虚函数表**，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的**地址替换为重新写的函数地址**。使用了虚函数，会增加访问内存开销，降低效率。



简述C++虚函数作用及底层实现原理

要点是要答出虚函数表和虚函数表指针的作用。C++中虚函数使用虚函数表和 虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地 址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的**开始地址处**）， 它指向对象所在类的虚函数表的地址；在**多继承环境下，会存在多个虚函数表指针**，分别指向对应 不同基类的虚函数表。虚函数是**与对象动态绑定**的



析构函数需要是虚函数？

在delete时只会调用父类的析构函数，而不能调用子类的析构函数，造成内存泄露等问题

inline函数可以是虚函数吗？

不能，因为inline函数没有地址，无法把地址放到虚函数表中。

构造函数可以是虚函数吗?

不能,因为对象中的虚表指针是在构造函数初始化列表阶段才初始化的



final：修饰虚函数，表示该虚函数不能再被继承

override: 检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。



虚函数表，编译时生成

虚函数指针，初始化时生成

虚基类：





### 智能指针

智能指针的类都是栈上的对象，结束时会自动被释放。

shared 和 unique区别

unique具有**唯一性**，对指向的对象值存在唯一的unique_ptr。unique_ptr不可复制，赋值，但是move()可以转换对象的所有权，局部变量的返回值除外。与shared_ptr相比，若**自定义删除器**，需要**在声明处指定删除器类型**，而shared不需要，**shared**自定义删除器**只需要指定删除器对象即可**，在赋值时，可以随意赋值，删除器对象也会被赋值给新的对象。



shared_ptr 形成环：

引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要**手动打破循环引用或使用weak_ptr**。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。



### 右值引用

右值引用 T &&

右值引用就是必须绑定到右值

 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：
**消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。**

std::move语句可以将左值变为右值而避免拷贝构造

**std::make_move_iterator函数**用于从普通迭代器获得移动迭代器。对移动迭代器解引用将会获得对应的右值引用，从而方便的对整个容器进行移动操作

#### 引用折叠规则

**除了T&& &&折叠为T&&之外的所有情况均折叠为T&**

**std::forward（val）返回类型是T&&,**这时，根据折叠规则，如果实参val是个左值，则返回T&;如果是右值，则返回T&&。

### 构造函数

移动构造函数 	(A&&)

拷贝构造函数	(const A &)



### lambda

```

```



### RAII

资源获取就是初始化

一种管理资源，避免泄露的惯用法

创建资源，析构释放

生命周期结束时，自动调用析构函数

RAII 问题：背后偷偷调用了默认的构造函数，生成临时对象，析构时将锁进行了释放，没有做到锁的配对使用