## OLA & OLS 算法

OLA 重叠相加法

OLS 重叠保留法

#### OLA 算法步骤

1. 将x(n)分段，每段长为M，保证M接近N即可，然后将xk(n)补零延长到L=M+N−1，计算L点FFT得到XK(K)
2. 将h(n)补零延长至L=M+N−1，计算LL点FFT得到H(K)。
3. 计算yk(k)=XK(K)∗H(K)，然后求L点的IFFT,得到yk(K)

观察可以发现，每段xk(n)长为M，恢复得到的yk(K)长为L，L>M，那怎么将每段yk(K)拼接起来呢，方法为在还原的时候将重叠部分相加就可以了，这也是重叠相加法名字的由来。
#### 代码实现

```matlab
close all;
clear;
clc;
h = [1,7,8];
N = length(h);

x = [5,8,9,6,3,4,8,2,1,7,5,6];
M = 4;

L = M+N-1;


x1 = x(1:4);
x2 = x(5:8);
x3 = x(9:12);

H = fft(h,L);

Y1 = fft(x1,L).*H;
Y2 = fft(x2,L).*H;
Y3 = fft(x3,L).*H;

y1 = ifft(Y1,L);
y2 = ifft(Y2,L);
y3 = ifft(Y3,L);

y_conv = conv(h,x)
y_ola = [y1(1:4),y1(5:6)+...
                y2(1:2),y2(3:4),y2(5:6)+...
                                 y3(1:2),y3(3:6)]
```

#### OLS 算法步骤

1. 将x(n)分段，每段长为M，保证M接近N即可，然后 将每段xk(n)向前多取N−1个点，第一段前面补N−1个0，则每段xk(n)长为L=M+N−1，计算L点FFT得到XK(K)
2. 将h(n)补零延长至L=M+N−1，计算L点FFT得到H(K)。
3. 计算yk(k)=XK(K)∗H(K)，然后求L点的IFFT,得到yk(K)

```matlab
close all
clear;
clc all;
h = [1,7,8];
N = length(h);

x0 = [5,8,9,6,3,4,8,2,1,7,5,6];
M = 4;

x = [zeros(1,N-1),x0];

L = M+N-1;

x1 = x(1:6);
x2 = x(5:10);
x3 = x(9:14);
x4 = [x(13:14),zeros(1,4)];
H = fft(h,L);

Y1 = fft(x1,L).*H;
Y2 = fft(x2,L).*H;
Y3 = fft(x3,L).*H;
Y4 = fft(x4,L).*H;

y1 = ifft(Y1,L);
y2 = ifft(Y2,L);
y3 = ifft(Y3,L);
y4 = ifft(Y4,L);

y_conv = conv(h,x0)
y_ols = [y1(3:6),y2(3:6),y3(3:6),y4(3:6)]
```

#### WOLA 

WOLA 加权重叠相加法，在 IFFT 变换之后还要对数据进行加权，加权使用窗函数实现，然后按照 FFT 对应段再相加，这个窗被称为综合窗或输出窗，重叠相加结果是最终结果。

加窗的目的是减少截断效应带来的不利影响，以抑制帧边缘主观听感上的不连续性，常用于语音信号处理场景。OLA 分段会产生时域混叠，这会在逐渐减弱的时域信号拼接处引入峰值，从而在听感上会有“啪啪声”，加权OLA 的方法就是为了避免这一问题。WOLA 方法的分析窗和综合窗常用一样的。

常用的窗函数有：

- 均方根汉宁窗(root-Hann)
- 均方根布莱克曼窗(root-Blackman)

不同的窗具有的最优重叠长度不一样，如布莱克曼哈里斯窗（Blackman-Harris）的最优重叠长度为窗长的 66.1%，而汉明窗和汉宁窗的最优重叠长度为窗长的 50%