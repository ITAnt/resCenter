## FFmpeg 基础概念



#### Bitstream Filter

1. 比特流滤波器作用在编码后的数据上，而不是未压缩的数据。
2. 在不解码的基础上执行比特流级别的修改。

示例

```shell
ffmpeg -i input.mp4 -codec copy -bsf:v h264_mp4toannexb output.ts
```

这个是把mp4容器格式改为ts容器格式，需要把h.264的封装格式从mp4改成annexb。

h.264编码有两种封装格式

1. 一种是annexb模式, 它是传统模式, 有startcode, SPS和PPS在Element Stream中.
2. 另一种是mp4模式, 一般Mp4, MKV, AVI都没有startcode, SPS和PPS以及其他信息被封装容器中. 每一帧前面是这一帧的长度值, 很多解码器只支持annexb模式, 因此需要对Mp4模式做转换.



#### 分离出多媒体文件中的音频流

FLV，MP4这些属于“特殊容器”。经过仔细对比后发现，调用av_read_frame()后得到的AVPacket里面的内容是AAC纯数据，就是那种不包含ADTS文件头的AAC数据。因此如果想要得到可以播放的AAC文件，需要在每个AVPacket前面加上7字节ADTS文件头。

#### 分离出多媒体文件中的H.264码流

FLV，MP4这些属于“特殊容器”，需要经过以下处理才能得到可播放的H.264码流

第一次存储AVPacket之前需要在前面加上H.264的SPS和PPS。这些信息存储在AVCodecContext的extradata里面。

并且需要使用FFMPEG中的名为"h264_mp4toannexb"的bitstream filter 进行处理。

```c
unsigned char *dummy=NULL;   //输入的指针  
int dummy_len;  
AVBitStreamFilterContext* bsfc =  av_bitstream_filter_init("h264_mp4toannexb");    
av_bitstream_filter_filter(bsfc, pCodecCtx, NULL, &dummy, &dummy_len, NULL, 0, 0);  
fwrite(pCodecCtx->extradata,pCodecCtx-->extradata_size,1,fp);  
av_bitstream_filter_close(bsfc);    
free(dummy);  
```

AVPacket中的数据起始处没有分隔符(0x00000001), 也不是0x65、0x67、0x68、0x41等字节，所以可以AVPacket肯定这不是标准的nalu。其实，AVPacket前4个字表示的是nalu的长度，从第5个字节开始才是nalu的数据。所以直接将AVPacket前4个字节替换为0x00000001即可得到标准的nalu数据。

```c
char nal_start[]={0,0,0,1};  
fwrite(nal_start,4,1,fp);  
fwrite(pkt->data+4,pkt->size-4,1,fp);  
fclose(fp);  
```

#### swscale图片缩放算法

> SWS_FAST_BILINEAR
>
> SWS_BILINEAR
>
> SWS_BICUBIC
>
> SWS_X
>
> SWS_POINT
>
> SWS_AREA
>
> SWS_BICUBLIN
>
> SWS_GAUSS
>
> SWS_SINC
>
> SWS_LANCZOS
>
> SWS_SPLINE

如果对图像的缩放，要追求高效，比如说是视频图像的处理，在不明确是放大还是缩小时，直接使用SWS_FAST_BILINEAR算法即可。如果明确是要缩小并显示，建议使用Point算法，如果是明确要放大并显示，其实使用CImage的Strech更高效。当然，如果不计速度追求画面质量。在上面的算法中，选择帧率最低的那个即可，画面效果一般是最好的。