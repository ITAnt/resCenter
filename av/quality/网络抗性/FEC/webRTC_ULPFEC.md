FEC 在 WebRTC 中的实现

WebRTC主要采取两种手段对抗网络丢包：丢包重传(NACK)和前向纠错(FEC)。ULPFEC(Uneven Level Protection FEC，直译为非均等保护前向纠错)则是WebRTC实现的FEC方案之一。

ULPFEC理论学习

ULPFEC由RFC5109 定义，在WebRTC中以RED格式进一步封装在RTP中传输。该标准使用XOR操作基于多个多媒体数据包生成FEC数据包，然后在接收端根据FEC数据包和已接收数据包恢复丢失的数据包。ULPFEC**能够针对不同的数据包提供不同的保护级别**，从而对重要的数据包提供更多的保护。

ULPFEC基本概念

ULPFEC数据包中包含发送端需要告知接收端的一些重要信息，包括本FEC数据包所保护的**媒体数据**、**保护级别**和**每个级别的保护长度**。特别地，FEC数据包针对每个保护级别k设置一个**偏移量掩码m(k)**，如果m(k)的第i位被设置为1，则序列号为N＋i的媒体数据包在本FEC包的第k级别被保护。其中N为基准序列号，在本FEC包中设置。第k级别保护的媒体数据大小由L(k)指示，该值也在FEC包中设置。以上**保护长度**、**偏移量掩码**、**负载类型**和**基准序列号**能够完全确定生成FEC数据包中的**奇偶校验码**。

通常情况下，对于媒体数据包，不同部分的重要程度不一样。因此，我们可以**针对数据包的不同部分实施不同程度保护**（即非均等保护前向纠错），以充分利用带宽资源。更多带宽花费在更重要的数据部分，相反，较少带宽花费在不那么重要的数据部分。媒体数据包根据重要程度划分为若干部分，每个部分就是我们所说的保护级别，每个部分的长度即为保护长度，每个FEC包可携带多个保护级别的奇偶校验码。根据数据包不同部分重要程度进行保护的算法，就是所谓的ULPFEC非均等保护前向纠错。

 ULPFEC 核心

针对数据包的不同部分实施不同程度保护。

ULPFEC报文格式

ULPFEC报文由一个**头部**和**多个保护级别**组成，每个保护级别包含级别头部和负载。

FEC头部

FEC头部为10字节，包含内容如下：

- E flag：扩展位，供将来使用，当前设置为0。
- L flag：指示长偏移掩码是否使用，0表示偏移掩码为16位，1表示为48位。
- P/X/CC/M/PT recovery field：由本FEC包所保护的所有媒体数据包的RTP头部的**P/X/CC/M/PT** flag位经**XOR**操作后得到。
- SN base：本FEC包所保护的媒体数据包的RTP报文的**序列号**最小值。
- TS recovery field: 由本FEC包所保护的所有媒体数据包的RTP头部中的**Timestamp字**段经XOR操作后得到。
- Length recovery field: 由本FEC包所保护的所有媒体数据包的**负载长度**(包括CSRC、RTP头部扩展、负载和padding的长度之和，以16位无符号网络序表示)经XOR操作后得到。

ULP头部

根据FEC头部中E flag是否设置，FEC级别头部长度为4字节或8字节。Protection length为2字节表示本级别所保护的媒体数据的长度；mask为2字节(如E flag设置则为6字节)表示偏移掩码，指示本级别所保护的媒体数据包的分布情况。如果偏移掩码的第i位置为1，则表示第N＋i个媒体数据包在本级别中受保护，其中N为FEC头部中的媒体数据基准序列号。

偏移掩码的设置遵循以下规则

1. 媒体数据包在高于0级别的等级中只能被保护一次，但是可以在0级别中被多个FEC包保护，只要这些FEC包在0级别的保护长度相等。
2. 如果媒体数据包在p级别被保护，那么它也必须在p-1级别被保护。注意保护p级别的FEC包和保护p-1级别的FEC包可能不是同一个。
3. 如果FEC包包含p级别保护，那么它也必须包含p-1级别保护。注意p级别保护的数据包可能和p-1级别保护的数据包不是同一个。

ULPFEC报文构造

通过对比RFC3550中RTP头部的定义我们可以发现，FEC头部和RTP头部非常类似：除E/L flag之外，FEC头部前8字节基本上和RTP头部前8字节定义相同，而且其数据也来源于媒体数据包的RTP头部(经XOR运算后得到)。而后两字节length recovery也是对媒体数据RTP负载长度计算得到的。因此，FEC头部就是它所保护的所有RTP报文的头部经XOR计算后得到的。

据此，我们很容易得到FEC头部的构造办法：对于本FEC包保护的所有媒体数据包，针对其RTP头部的前8字节进行XOR运算，最终结果根据格式定义填入到FEC头部中。

需要注意的是FEC头部只保护RTP头部的前12字节，对于CSRC和RTP Extentions部分，FEC将其视为RTP负载部分进行保护。

对于保护级别的头部，根据预先确定的本级别保护长度和保护媒体数据集合，分别填入保护长度字段和设置偏移掩码字段。对于保护级别的负载部分，则是由本级别保护的媒体数据包的对应部分进行XOR运算后得到，然后填入负载位置。



ULPFEC 报文发送

ULPFEC 报文可采取两种方式发送：

- 使用独立的 RTP 流发送
- 封装在 RED 报文中随源媒体数据一起发送

WebRTC采用第二种方式。

RED(Redundant Coding)是针对RTP负载数据的二次封装，所以叫冗余编码，其定义在RFC2198[5]中。RED有两种数据封装格式：Primary Data Block和Redundant Data Block。

Redundant Data Block

- F flag：指示本Block后续是否还有其他Block跟随，1表示有，0表示无。
- block PT：本Block 的Payload Type，也即原始RTP负载数据的PT。
- Timestamp offset：本Block相对于原始RTP头部中timestamp的偏移量。
- Block length：本Block的长度。

Primary Data Block

Primary Data Block表示本Block之后再无Block。

FEC报文在构造之后，会封装为RED格式，然后再进一步封装为RTP报文，最后随其他RTP报文(也已经封装为RED格式)一起发送到网络。在接收端，RTP报文首先根据负载判断为RED报文后，进行解包操作，得到原始RTP/FEC报文，然后继续接下来的流程。

ULPFEC报文恢复

在接收端RTP数据包经过RED解包操作后，得到原始RTP包或者FEC包，前者进一步发送到VCM模块并存储在FEC处理模块，后者则进行丢包检测和数据包恢复工作。FEC包能够在媒体数据包丢失的情况下恢复，丢失的媒体数据包可以部分或全部恢复，这取决于实际的数据包丢失情况。丢失媒体数据包恢复需要两步：

1. 确定恢复丢失媒体数据包所需要的FEC数据包和未丢失媒体数据包的集合，有多种算法可确定这个数据包集合。
2. 重建丢失的媒体数据包，这又包括重建RTP头部和RTP负载。

重建RTP头部

重建RTP负载

