typedef struct webrtc_ec {
    void *AEC_inst;
    NsHandle *NS_inst;
    unsigned options;
    unsigned samples_per_frame;
    unsigned tail;
    unsigned clock_rate;
    unsigned channel_count;
    unsigned subframe_len;
    sample tmp_buf[BUF_LEN];
    sample tmp_buf2[BUF_LEN];
#if SHOW_DELAY_METRICS
    unsigned	counter;
#endif
} webrtc_ec;


//Create

	echo->AEC_inst = WebRtcAec_Create();
	WebRtcAec_Init(echo->AEC_inst, clock_rate, clock_rate);

	// 延时估计，大于40ms 的差值就会有影响
	// 5-10s 自适应最佳delay
	WebRtcAec_enable_delay_agnostic(WebRtcAec_aec_core(echo->AEC_inst), 1);



//setconfig
	USE_MOBILE
		echoMode
			3	中（默认）
			0	低
			4	强
		skewMode 
			0

	UNUSE_MOBILE
		nlpMode
			0	低
			1	中（默认）
			2	强
		cngMode
			1

	delay_metrics:
		metricsMode 1
		delay_logging 1
	no_delay_metrics:
		metricsMode	0
		delay_logging	0

	WebRtcAec_set_config(AEC_inst, aec_config)


/*
reset
*/
	Re-initialize the EC
	WebRtcAec_Init(echo->AEC_inst, echo->clock_rate, echo->clock_rate);
	//setconfig
 
 
 //cancel echo
	WebRtcAec_BufferFarend(echo->AEC_inst, buf_ptr,echo->subframe_len);
 
	USE_MOBILE:
		WebRtcNsx_Process(echo->NS_inst, &buf_ptr, 
						echo->channel_count,&out_buf_ptr);
		
		WebRtcAecm_Process(echo->AEC_inst, &rec_frm[frm_idx],
						(echo->NS_inst? buf_ptr: NULL),
                        out_buf_ptr, echo->subframe_len,
                        echo->tail);
	
	UNUSE_MOBILE:
		WebRtcNs_Analyze(echo->NS_inst, buf_ptr);
		
		WebRtcAec_Process(echo->AEC_inst, &buf_ptr,
                                   echo->channel_count, &out_buf_ptr,
                                   echo->subframe_len, (int16_t) echo->tail, 0);
								   

//METRICS	数据统计
	WebRtcAec_GetDelayMetrics(echo->AEC_inst, &median, &std,&frac_delay)

//Destroy
	WebRtcAec_Free(echo->AEC_inst);


//NS create

	echo->NS_inst = WebRtcNs_Create();
	WebRtcNs_Init(echo->NS_inst, clock_rate);

//NS process
	UNUSE_MOBILE
		WebRtcNs_Process(echo->NS_inst, &buf_ptr,
                             echo->channel_count, &out_buf_ptr);


//NS Destroy
	WebRtcNs_Free(echo->NS_inst);
	
	
	
	
	
	
//aec
typedef struct {
  int delayCtr;
  int sampFreq;
  int splitSampFreq;
  int scSampFreq;
  float sampFactor;  // scSampRate / sampFreq
  short skewMode;
  int bufSizeStart;
  int knownDelay;
  int rate_factor;

  short initFlag;  // indicates if AEC has been initialized

  // Variables used for averaging far end buffer size
  short counter;
  int sum;
  short firstVal;
  short checkBufSizeCtr;

  // Variables used for delay shifts
  short msInSndCardBuf;
  short filtDelay;  // Filtered delay estimate.
  int timeForDelayChange;
  int startup_phase;
  int checkBuffSize;
  short lastDelayDiff;

#ifdef WEBRTC_AEC_DEBUG_DUMP
  FILE* bufFile;
  FILE* delayFile;
  FILE* skewFile;
#endif

  // Structures
  void* resampler;

  int skewFrCtr;
  int resample;  // if the skew is small enough we don't resample
  int highSkewCtr;
  float skew;

  RingBuffer* far_pre_buf;  // Time domain far-end pre-buffer.

  int lastError;

  int farend_started;

  AecCore* aec;
} Aec;


//create
	aecpc->aec = WebRtcAec_CreateAec();
	aecpc->resampler = WebRtcAec_CreateResampler();
	//远端	“almost” an FFT  buffer (64-1)
	aecpc->far_pre_buf = WebRtc_CreateBuffer(PART_LEN2 + kResamplerBufferSize, sizeof(float));
			64*2 + (80*4) 
	aecpc->initFlag = 0;
	aecpc->lastError = 0;	
	
//init
	aecpc->sampFreq = sampFreq;	8000
	aecpc->scSampFreq = scSampFreq;	8000
	WebRtcAec_InitAec(aecpc->aec, aecpc->sampFreq)
	WebRtcAec_InitResampler(aecpc->resampler, aecpc->scSampFreq)
	WebRtc_InitBuffer(aecpc->far_pre_buf);
	WebRtc_MoveReadPtr(aecpc->far_pre_buf, -PART_LEN);	-64	//Start overlap
	aecpc->initFlag = initCheck;	42	//indicates that initialization has been done
	aecpc->splitSampFreq = sampFreq;	8000
	aecpc->delayCtr = 0;
	aecpc->sampFactor =1.0;
	//Sampling frequency multiplier (SWB is processed as 160 frame size).
	aecpc->rate_factor = 1;
	
	aecpc->sum = 0;
	aecpc->counter = 0;
	aecpc->checkBuffSize = 1;
	aecpc->firstVal = 0;
	
	//We skip the startup_phase completely (setting to 0) if DA-AEC is enabled,but not extended_filter mode.
	aecpc->startup_phase = WebRtcAec_extended_filter_enabled(aecpc->aec) ||
      !WebRtcAec_delay_agnostic_enabled(aecpc->aec);
	  
	aecpc->bufSizeStart = 0;
	aecpc->checkBufSizeCtr = 0;
	aecpc->msInSndCardBuf = 0;
	aecpc->filtDelay = -1;  // -1 indicates an initialized state.
	aecpc->timeForDelayChange = 0;
	aecpc->knownDelay = 0;
	aecpc->lastDelayDiff = 0;

	aecpc->skewFrCtr = 0;
	aecpc->resample = kAecFalse;
	aecpc->highSkewCtr = 0;
	aecpc->skew = 0;

	aecpc->farend_started = 0;

	// Default settings.
	aecConfig.nlpMode = kAecNlpModerate;
	aecConfig.skewMode = kAecFalse;
	aecConfig.metricsMode = kAecFalse;
	aecConfig.delay_logging = kAecFalse;
	

//set config
	WebRtcAec_SetConfigCore(
      self->aec, config.nlpMode, config.metricsMode, config.delay_logging);
	

//only buffer L band for farend
//bufferFarend
	
	if (aecpc->skewMode == kAecTrue && aecpc->resample == kAecTrue) {
		// Resample and get a new number of samples
		WebRtcAec_ResampleLinear(aecpc->resampler,
								 farend,
								 nrOfSamples,
								 aecpc->skew,
								 new_farend,
								 &newNrOfSamples);
		farend_ptr = new_farend;
	}
	
	aecpc->farend_started = 1;
	WebRtcAec_SetSystemDelay(
		aecpc->aec, WebRtcAec_system_delay(aecpc->aec) + (int)newNrOfSamples);
	
	// Write the time-domain data to |far_pre_buf|
	WebRtc_WriteBuffer(aecpc->far_pre_buf, farend_ptr, newNrOfSamples)
	
	// Transform to frequency domain if we have enough data.
	WebRtc_ReadBuffer(aecpc->far_pre_buf, (void**)&ptmp, tmp, PART_LEN2);
	//Convert far-end partition to the frequency domain with windowing.
    WebRtcAec_BufferFarendPartition(aecpc->aec, ptmp);
	
	// Rewind |far_pre_buf| PART_LEN samples for overlap before continuing.
	WebRtc_MoveReadPtr(aecpc->far_pre_buf, -PART_LEN);
	

//UNUSE_MOBILE
WebRtcNs_Analyze



//UNUSE_MOBILE
WebRtcAec_Process
	if (WebRtcAec_extended_filter_enabled(aecpc->aec)){
		ProcessExtended(aecpc,
                    nearend,
                    num_bands,
                    out,
                    nrOfSamples,
                    msInSndCardBuf,
                    skew);
	} else {
		if (ProcessNormal(aecpc,
                      nearend,
                      num_bands,
                      out,
                      nrOfSamples,
                      msInSndCardBuf,
                      skew) != 0) {
		retVal = -1;
		}
	}
	
